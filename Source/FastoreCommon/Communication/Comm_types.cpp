/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Comm_types.h"

#include <algorithm>

namespace fastore { namespace communication {

int _kRepositoryStatusValues[] = {
  RepositoryStatus::Loading,
  RepositoryStatus::Unloading,
  RepositoryStatus::Online,
  RepositoryStatus::Offline
};
const char* _kRepositoryStatusNames[] = {
  "Loading",
  "Unloading",
  "Online",
  "Offline"
};
const std::map<int, const char*> _RepositoryStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kRepositoryStatusValues, _kRepositoryStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kServiceStatusValues[] = {
  ServiceStatus::Unknown,
  ServiceStatus::Offline,
  ServiceStatus::Online,
  ServiceStatus::Unreachable
};
const char* _kServiceStatusNames[] = {
  "Unknown",
  "Offline",
  "Online",
  "Unreachable"
};
const std::map<int, const char*> _ServiceStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kServiceStatusValues, _kServiceStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockModeValues[] = {
  LockMode::Read,
  LockMode::Write
};
const char* _kLockModeNames[] = {
  "Read",
  "Write"
};
const std::map<int, const char*> _LockMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLockModeValues, _kLockModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* NetworkAddress::ascii_fingerprint = "E17E126D15049701494262EE3246F603";
const uint8_t NetworkAddress::binary_fingerprint[16] = {0xE1,0x7E,0x12,0x6D,0x15,0x04,0x97,0x01,0x49,0x42,0x62,0xEE,0x32,0x46,0xF6,0x03};

uint32_t NetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NetworkAddress");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->port);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkAddress &a, NetworkAddress &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

const char* WorkerState::ascii_fingerprint = "671173BA4A0889C63295D13F187AC67E";
const uint8_t WorkerState::binary_fingerprint[16] = {0x67,0x11,0x73,0xBA,0x4A,0x08,0x89,0xC6,0x32,0x95,0xD1,0x3F,0x18,0x7A,0xC6,0x7E};

uint32_t WorkerState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_podID = false;
  bool isset_repositoryStatus = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->podID);
          isset_podID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->repositoryStatus.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              ColumnID _key5;
              xfer += iprot->readI64(_key5);
              RepositoryStatus::type& _val6 = this->repositoryStatus[_key5];
              int32_t ecast7;
              xfer += iprot->readI32(ecast7);
              _val6 = (RepositoryStatus::type)ecast7;
            }
            iprot->readMapEnd();
          }
          isset_repositoryStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_podID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_repositoryStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkerState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WorkerState");

  xfer += oprot->writeFieldBegin("podID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->podID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("repositoryStatus", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->repositoryStatus.size()));
    std::map<ColumnID, RepositoryStatus::type> ::const_iterator _iter8;
    for (_iter8 = this->repositoryStatus.begin(); _iter8 != this->repositoryStatus.end(); ++_iter8)
    {
      xfer += oprot->writeI64(_iter8->first);
      xfer += oprot->writeI32((int32_t)_iter8->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkerState &a, WorkerState &b) {
  using ::std::swap;
  swap(a.podID, b.podID);
  swap(a.repositoryStatus, b.repositoryStatus);
  swap(a.port, b.port);
}

const char* ServiceState::ascii_fingerprint = "A1199E740B9B4CA22D6FBE74944130AF";
const uint8_t ServiceState::binary_fingerprint[16] = {0xA1,0x19,0x9E,0x74,0x0B,0x9B,0x4C,0xA2,0x2D,0x6F,0xBE,0x74,0x94,0x41,0x30,0xAF};

uint32_t ServiceState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_timeStamp = false;
  bool isset_address = false;
  bool isset_workers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->status = (ServiceStatus::type)ecast9;
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeStamp);
          isset_timeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->workers.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            iprot->readListBegin(_etype13, _size10);
            this->workers.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->workers[_i14].read(iprot);
            }
            iprot->readListEnd();
          }
          isset_workers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_workers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServiceState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceState");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->timeStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("workers", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->workers.size()));
    std::vector<WorkerState> ::const_iterator _iter15;
    for (_iter15 = this->workers.begin(); _iter15 != this->workers.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceState &a, ServiceState &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.timeStamp, b.timeStamp);
  swap(a.address, b.address);
  swap(a.workers, b.workers);
}

const char* HiveState::ascii_fingerprint = "A1CC6D56385C7C1FE3F049C8D742F1FF";
const uint8_t HiveState::binary_fingerprint[16] = {0xA1,0xCC,0x6D,0x56,0x38,0x5C,0x7C,0x1F,0xE3,0xF0,0x49,0xC8,0xD7,0x42,0xF1,0xFF};

uint32_t HiveState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topologyID = false;
  bool isset_services = false;
  bool isset_reportingHostID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topologyID);
          isset_topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->services.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              HostID _key21;
              xfer += iprot->readI64(_key21);
              ServiceState& _val22 = this->services[_key21];
              xfer += _val22.read(iprot);
            }
            iprot->readMapEnd();
          }
          isset_services = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportingHostID);
          isset_reportingHostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topologyID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_services)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reportingHostID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HiveState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HiveState");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("services", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->services.size()));
    std::map<HostID, ServiceState> ::const_iterator _iter23;
    for (_iter23 = this->services.begin(); _iter23 != this->services.end(); ++_iter23)
    {
      xfer += oprot->writeI64(_iter23->first);
      xfer += _iter23->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportingHostID", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->reportingHostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveState &a, HiveState &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.services, b.services);
  swap(a.reportingHostID, b.reportingHostID);
}

const char* Host::ascii_fingerprint = "9F0802A2C6E78AE110DA07A538916DA0";
const uint8_t Host::binary_fingerprint[16] = {0x9F,0x08,0x02,0xA2,0xC6,0xE7,0x8A,0xE1,0x10,0xDA,0x07,0xA5,0x38,0x91,0x6D,0xA0};

uint32_t Host::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pods = false;
  bool isset_stashes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->pods.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              PodID _key29;
              xfer += iprot->readI64(_key29);
              ColumnIDs& _val30 = this->pods[_key29];
              {
                _val30.clear();
                uint32_t _size31;
                ::apache::thrift::protocol::TType _etype34;
                iprot->readListBegin(_etype34, _size31);
                _val30.resize(_size31);
                uint32_t _i35;
                for (_i35 = 0; _i35 < _size31; ++_i35)
                {
                  xfer += iprot->readI64(_val30[_i35]);
                }
                iprot->readListEnd();
              }
            }
            iprot->readMapEnd();
          }
          isset_pods = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->stashes.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _ktype37;
            ::apache::thrift::protocol::TType _vtype38;
            iprot->readMapBegin(_ktype37, _vtype38, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              StashID _key41;
              xfer += iprot->readI64(_key41);
              ColumnIDs& _val42 = this->stashes[_key41];
              {
                _val42.clear();
                uint32_t _size43;
                ::apache::thrift::protocol::TType _etype46;
                iprot->readListBegin(_etype46, _size43);
                _val42.resize(_size43);
                uint32_t _i47;
                for (_i47 = 0; _i47 < _size43; ++_i47)
                {
                  xfer += iprot->readI64(_val42[_i47]);
                }
                iprot->readListEnd();
              }
            }
            iprot->readMapEnd();
          }
          isset_stashes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pods)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stashes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Host::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Host");

  xfer += oprot->writeFieldBegin("pods", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->pods.size()));
    std::map<PodID, ColumnIDs> ::const_iterator _iter48;
    for (_iter48 = this->pods.begin(); _iter48 != this->pods.end(); ++_iter48)
    {
      xfer += oprot->writeI64(_iter48->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter48->second.size()));
        std::vector<ColumnID> ::const_iterator _iter49;
        for (_iter49 = _iter48->second.begin(); _iter49 != _iter48->second.end(); ++_iter49)
        {
          xfer += oprot->writeI64((*_iter49));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stashes", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->stashes.size()));
    std::map<StashID, ColumnIDs> ::const_iterator _iter50;
    for (_iter50 = this->stashes.begin(); _iter50 != this->stashes.end(); ++_iter50)
    {
      xfer += oprot->writeI64(_iter50->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter50->second.size()));
        std::vector<ColumnID> ::const_iterator _iter51;
        for (_iter51 = _iter50->second.begin(); _iter51 != _iter50->second.end(); ++_iter51)
        {
          xfer += oprot->writeI64((*_iter51));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Host &a, Host &b) {
  using ::std::swap;
  swap(a.pods, b.pods);
  swap(a.stashes, b.stashes);
}

const char* Topology::ascii_fingerprint = "E480B4FEEBBC45D7112359D5200F0468";
const uint8_t Topology::binary_fingerprint[16] = {0xE4,0x80,0xB4,0xFE,0xEB,0xBC,0x45,0xD7,0x11,0x23,0x59,0xD5,0x20,0x0F,0x04,0x68};

uint32_t Topology::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topologyID = false;
  bool isset_hosts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topologyID);
          isset_topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hosts.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _ktype53;
            ::apache::thrift::protocol::TType _vtype54;
            iprot->readMapBegin(_ktype53, _vtype54, _size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              HostID _key57;
              xfer += iprot->readI64(_key57);
              Host& _val58 = this->hosts[_key57];
              xfer += _val58.read(iprot);
            }
            iprot->readMapEnd();
          }
          isset_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topologyID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hosts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Topology::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Topology");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hosts.size()));
    std::map<HostID, Host> ::const_iterator _iter59;
    for (_iter59 = this->hosts.begin(); _iter59 != this->hosts.end(); ++_iter59)
    {
      xfer += oprot->writeI64(_iter59->first);
      xfer += _iter59->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Topology &a, Topology &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.hosts, b.hosts);
}

const char* OptionalHiveState::ascii_fingerprint = "4D5C48147F5DC789C640DAB00E9C8BC3";
const uint8_t OptionalHiveState::binary_fingerprint[16] = {0x4D,0x5C,0x48,0x14,0x7F,0x5D,0xC7,0x89,0xC6,0x40,0xDA,0xB0,0x0E,0x9C,0x8B,0xC3};

uint32_t OptionalHiveState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hiveState.read(iprot);
          this->__isset.hiveState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalHiveState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OptionalHiveState");

  if (this->__isset.hiveState) {
    xfer += oprot->writeFieldBegin("hiveState", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->hiveState.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.potentialWorkers) {
    xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->potentialWorkers);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalHiveState &a, OptionalHiveState &b) {
  using ::std::swap;
  swap(a.hiveState, b.hiveState);
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* OptionalServiceState::ascii_fingerprint = "9207B221A88F594F4277871EFF583B03";
const uint8_t OptionalServiceState::binary_fingerprint[16] = {0x92,0x07,0xB2,0x21,0xA8,0x8F,0x59,0x4F,0x42,0x77,0x87,0x1E,0xFF,0x58,0x3B,0x03};

uint32_t OptionalServiceState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serviceState.read(iprot);
          this->__isset.serviceState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalServiceState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OptionalServiceState");

  if (this->__isset.serviceState) {
    xfer += oprot->writeFieldBegin("serviceState", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->serviceState.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.potentialWorkers) {
    xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->potentialWorkers);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalServiceState &a, OptionalServiceState &b) {
  using ::std::swap;
  swap(a.serviceState, b.serviceState);
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* LockExpired::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t LockExpired::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t LockExpired::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockID);
          this->__isset.lockID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockExpired::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockExpired");

  xfer += oprot->writeFieldBegin("lockID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockExpired &a, LockExpired &b) {
  using ::std::swap;
  swap(a.lockID, b.lockID);
  swap(a.__isset, b.__isset);
}

const char* LockTimedOut::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t LockTimedOut::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t LockTimedOut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockTimedOut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockTimedOut");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockTimedOut &a, LockTimedOut &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* AlreadyJoined::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t AlreadyJoined::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t AlreadyJoined::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hostID);
          this->__isset.hostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyJoined::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AlreadyJoined");

  xfer += oprot->writeFieldBegin("hostID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyJoined &a, AlreadyJoined &b) {
  using ::std::swap;
  swap(a.hostID, b.hostID);
  swap(a.__isset, b.__isset);
}

const char* NotJoined::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t NotJoined::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t NotJoined::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotJoined::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotJoined");

  xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->potentialWorkers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotJoined &a, NotJoined &b) {
  using ::std::swap;
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* Cell::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t Cell::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_rowID = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          isset_rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_rowID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->rowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.rowID, b.rowID);
  swap(a.value, b.value);
}

const char* ColumnWrites::ascii_fingerprint = "5A97C260CD70CD71BA72B43BB1F9A5E3";
const uint8_t ColumnWrites::binary_fingerprint[16] = {0x5A,0x97,0xC2,0x60,0xCD,0x70,0xCD,0x71,0xBA,0x72,0xB4,0x3B,0xB1,0xF9,0xA5,0xE3};

uint32_t ColumnWrites::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->includes.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            iprot->readListBegin(_etype63, _size60);
            this->includes.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->includes[_i64].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->excludes.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            iprot->readListBegin(_etype68, _size65);
            this->excludes.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->excludes[_i69].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.excludes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnWrites::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnWrites");

  if (this->__isset.includes) {
    xfer += oprot->writeFieldBegin("includes", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->includes.size()));
      std::vector<Cell> ::const_iterator _iter70;
      for (_iter70 = this->includes.begin(); _iter70 != this->includes.end(); ++_iter70)
      {
        xfer += (*_iter70).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excludes) {
    xfer += oprot->writeFieldBegin("excludes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->excludes.size()));
      std::vector<Cell> ::const_iterator _iter71;
      for (_iter71 = this->excludes.begin(); _iter71 != this->excludes.end(); ++_iter71)
      {
        xfer += (*_iter71).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnWrites &a, ColumnWrites &b) {
  using ::std::swap;
  swap(a.includes, b.includes);
  swap(a.excludes, b.excludes);
  swap(a.__isset, b.__isset);
}

const char* Statistic::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t Statistic::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t Statistic::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_total = false;
  bool isset_unique = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total);
          isset_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unique);
          isset_unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_total)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unique)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Statistic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Statistic");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->unique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Statistic &a, Statistic &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.unique, b.unique);
}

const char* RangeBound::ascii_fingerprint = "7D61C9AA00102AB4D8F72A1DA58297DC";
const uint8_t RangeBound::binary_fingerprint[16] = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

uint32_t RangeBound::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_inclusive = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inclusive);
          isset_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inclusive)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeBound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeBound");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inclusive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->inclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeBound &a, RangeBound &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.inclusive, b.inclusive);
}

const char* RangeRequest::ascii_fingerprint = "4C1A8C7B2474BEEF3B5899689B4AC289";
const uint8_t RangeRequest::binary_fingerprint[16] = {0x4C,0x1A,0x8C,0x7B,0x24,0x74,0xBE,0xEF,0x3B,0x58,0x99,0x68,0x9B,0x4A,0xC2,0x89};

uint32_t RangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ascending = false;
  bool isset_limit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          isset_ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->first.read(iprot);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->last.read(iprot);
          this->__isset.last = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          this->__isset.rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ascending)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeRequest");

  xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->ascending);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->limit);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.first) {
    xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->first.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last) {
    xfer += oprot->writeFieldBegin("last", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->last.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rowID) {
    xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->rowID);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeRequest &a, RangeRequest &b) {
  using ::std::swap;
  swap(a.ascending, b.ascending);
  swap(a.limit, b.limit);
  swap(a.first, b.first);
  swap(a.last, b.last);
  swap(a.rowID, b.rowID);
  swap(a.__isset, b.__isset);
}

const char* ValueRows::ascii_fingerprint = "25702B8D5E28AA39160F267DABBC8446";
const uint8_t ValueRows::binary_fingerprint[16] = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

uint32_t ValueRows::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_rowIDs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDs.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            iprot->readListBegin(_etype75, _size72);
            this->rowIDs.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readBinary(this->rowIDs[_i76]);
            }
            iprot->readListEnd();
          }
          isset_rowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rowIDs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ValueRows::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ValueRows");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rowIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDs.size()));
    std::vector<std::string> ::const_iterator _iter77;
    for (_iter77 = this->rowIDs.begin(); _iter77 != this->rowIDs.end(); ++_iter77)
    {
      xfer += oprot->writeBinary((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ValueRows &a, ValueRows &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.rowIDs, b.rowIDs);
}

const char* RangeResult::ascii_fingerprint = "A6BFD4A548133149EF24E6ED4F1025B8";
const uint8_t RangeResult::binary_fingerprint[16] = {0xA6,0xBF,0xD4,0xA5,0x48,0x13,0x31,0x49,0xEF,0x24,0xE6,0xED,0x4F,0x10,0x25,0xB8};

uint32_t RangeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_valueRowsList = false;
  bool isset_eof = false;
  bool isset_bof = false;
  bool isset_limited = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueRowsList.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            iprot->readListBegin(_etype81, _size78);
            this->valueRowsList.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->valueRowsList[_i82].read(iprot);
            }
            iprot->readListEnd();
          }
          isset_valueRowsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eof);
          isset_eof = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bof);
          isset_bof = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->limited);
          isset_limited = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_valueRowsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eof)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bof)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limited)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeResult");

  xfer += oprot->writeFieldBegin("valueRowsList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->valueRowsList.size()));
    std::vector<ValueRows> ::const_iterator _iter83;
    for (_iter83 = this->valueRowsList.begin(); _iter83 != this->valueRowsList.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eof", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->eof);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bof", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bof);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limited", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->limited);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeResult &a, RangeResult &b) {
  using ::std::swap;
  swap(a.valueRowsList, b.valueRowsList);
  swap(a.eof, b.eof);
  swap(a.bof, b.bof);
  swap(a.limited, b.limited);
}

const char* Query::ascii_fingerprint = "C06DB9A662129FF3CAE53510F3482EB5";
const uint8_t Query::binary_fingerprint[16] = {0xC0,0x6D,0xB9,0xA6,0x62,0x12,0x9F,0xF3,0xCA,0xE5,0x35,0x10,0xF3,0x48,0x2E,0xB5};

uint32_t Query::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDs.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            iprot->readListBegin(_etype87, _size84);
            this->rowIDs.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += iprot->readBinary(this->rowIDs[_i88]);
            }
            iprot->readListEnd();
          }
          this->__isset.rowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            iprot->readListBegin(_etype92, _size89);
            this->ranges.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += this->ranges[_i93].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Query::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Query");

  if (this->__isset.rowIDs) {
    xfer += oprot->writeFieldBegin("rowIDs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDs.size()));
      std::vector<std::string> ::const_iterator _iter94;
      for (_iter94 = this->rowIDs.begin(); _iter94 != this->rowIDs.end(); ++_iter94)
      {
        xfer += oprot->writeBinary((*_iter94));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ranges) {
    xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
      std::vector<RangeRequest> ::const_iterator _iter95;
      for (_iter95 = this->ranges.begin(); _iter95 != this->ranges.end(); ++_iter95)
      {
        xfer += (*_iter95).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Query &a, Query &b) {
  using ::std::swap;
  swap(a.rowIDs, b.rowIDs);
  swap(a.ranges, b.ranges);
  swap(a.__isset, b.__isset);
}

const char* OptionalValue::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t OptionalValue::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t OptionalValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OptionalValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalValue &a, OptionalValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Answer::ascii_fingerprint = "22FA14862D806BF9DFE908DF249FC6CF";
const uint8_t Answer::binary_fingerprint[16] = {0x22,0xFA,0x14,0x86,0x2D,0x80,0x6B,0xF9,0xDF,0xE9,0x08,0xDF,0x24,0x9F,0xC6,0xCF};

uint32_t Answer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDValues.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            iprot->readListBegin(_etype99, _size96);
            this->rowIDValues.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += this->rowIDValues[_i100].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.rowIDValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rangeValues.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            iprot->readListBegin(_etype104, _size101);
            this->rangeValues.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += this->rangeValues[_i105].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.rangeValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Answer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Answer");

  if (this->__isset.rowIDValues) {
    xfer += oprot->writeFieldBegin("rowIDValues", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rowIDValues.size()));
      std::vector<OptionalValue> ::const_iterator _iter106;
      for (_iter106 = this->rowIDValues.begin(); _iter106 != this->rowIDValues.end(); ++_iter106)
      {
        xfer += (*_iter106).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rangeValues) {
    xfer += oprot->writeFieldBegin("rangeValues", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rangeValues.size()));
      std::vector<RangeResult> ::const_iterator _iter107;
      for (_iter107 = this->rangeValues.begin(); _iter107 != this->rangeValues.end(); ++_iter107)
      {
        xfer += (*_iter107).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Answer &a, Answer &b) {
  using ::std::swap;
  swap(a.rowIDValues, b.rowIDValues);
  swap(a.rangeValues, b.rangeValues);
  swap(a.__isset, b.__isset);
}

const char* ReadResult::ascii_fingerprint = "959469BBAB93041F240CB804FD38363D";
const uint8_t ReadResult::binary_fingerprint[16] = {0x95,0x94,0x69,0xBB,0xAB,0x93,0x04,0x1F,0x24,0x0C,0xB8,0x04,0xFD,0x38,0x36,0x3D};

uint32_t ReadResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_answer = false;
  bool isset_revision = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->answer.read(iprot);
          isset_answer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          isset_revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_answer)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_revision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReadResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReadResult");

  xfer += oprot->writeFieldBegin("answer", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->answer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadResult &a, ReadResult &b) {
  using ::std::swap;
  swap(a.answer, b.answer);
  swap(a.revision, b.revision);
}

const char* RangePredicate::ascii_fingerprint = "2CB90755322001A9076140892C8A5F81";
const uint8_t RangePredicate::binary_fingerprint[16] = {0x2C,0xB9,0x07,0x55,0x32,0x20,0x01,0xA9,0x07,0x61,0x40,0x89,0x2C,0x8A,0x5F,0x81};

uint32_t RangePredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->first.read(iprot);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->last.read(iprot);
          this->__isset.last = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RangePredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangePredicate");

  if (this->__isset.first) {
    xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->first.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last) {
    xfer += oprot->writeFieldBegin("last", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->last.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangePredicate &a, RangePredicate &b) {
  using ::std::swap;
  swap(a.first, b.first);
  swap(a.last, b.last);
  swap(a.__isset, b.__isset);
}

const char* PrepareInfo::ascii_fingerprint = "1FD419B0C7C0D66084E5E1AF4EB2D9A4";
const uint8_t PrepareInfo::binary_fingerprint[16] = {0x1F,0xD4,0x19,0xB0,0xC7,0xC0,0xD6,0x60,0x84,0xE5,0xE1,0xAF,0x4E,0xB2,0xD9,0xA4};

uint32_t PrepareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fromRevision);
          this->__isset.fromRevision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rangePredicates.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _etype111;
            iprot->readListBegin(_etype111, _size108);
            this->rangePredicates.resize(_size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              xfer += this->rangePredicates[_i112].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.rangePredicates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrepareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PrepareInfo");

  if (this->__isset.fromRevision) {
    xfer += oprot->writeFieldBegin("fromRevision", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->fromRevision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("rangePredicates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rangePredicates.size()));
    std::vector<RangePredicate> ::const_iterator _iter113;
    for (_iter113 = this->rangePredicates.begin(); _iter113 != this->rangePredicates.end(); ++_iter113)
    {
      xfer += (*_iter113).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrepareInfo &a, PrepareInfo &b) {
  using ::std::swap;
  swap(a.fromRevision, b.fromRevision);
  swap(a.rangePredicates, b.rangePredicates);
  swap(a.filter, b.filter);
  swap(a.__isset, b.__isset);
}

const char* PrepareResult::ascii_fingerprint = "25038F937443AC9A2A06CEE5209E41BF";
const uint8_t PrepareResult::binary_fingerprint[16] = {0x25,0x03,0x8F,0x93,0x74,0x43,0xAC,0x9A,0x2A,0x06,0xCE,0xE5,0x20,0x9E,0x41,0xBF};

uint32_t PrepareResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_actualRevision = false;
  bool isset_validateRequired = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->actualRevision);
          isset_actualRevision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validateRequired);
          isset_validateRequired = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_actualRevision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_validateRequired)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrepareResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PrepareResult");

  xfer += oprot->writeFieldBegin("actualRevision", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->actualRevision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validateRequired", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->validateRequired);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrepareResult &a, PrepareResult &b) {
  using ::std::swap;
  swap(a.actualRevision, b.actualRevision);
  swap(a.validateRequired, b.validateRequired);
}

const char* NotLatest::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t NotLatest::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t NotLatest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latest);
          this->__isset.latest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotLatest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotLatest");

  xfer += oprot->writeFieldBegin("latest", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->latest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotLatest &a, NotLatest &b) {
  using ::std::swap;
  swap(a.latest, b.latest);
  swap(a.__isset, b.__isset);
}

const char* AlreadyPending::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t AlreadyPending::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t AlreadyPending::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pendingTransactionID);
          this->__isset.pendingTransactionID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->columnID);
          this->__isset.columnID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyPending::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AlreadyPending");

  xfer += oprot->writeFieldBegin("pendingTransactionID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->pendingTransactionID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->columnID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyPending &a, AlreadyPending &b) {
  using ::std::swap;
  swap(a.pendingTransactionID, b.pendingTransactionID);
  swap(a.columnID, b.columnID);
  swap(a.__isset, b.__isset);
}

const char* Conflict::ascii_fingerprint = "C1CFA7E6A57E07BC349AA430D41D6D57";
const uint8_t Conflict::binary_fingerprint[16] = {0xC1,0xCF,0xA7,0xE6,0xA5,0x7E,0x07,0xBC,0x34,0x9A,0xA4,0x30,0xD4,0x1D,0x6D,0x57};

uint32_t Conflict::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->details);
          this->__isset.details = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnIDs.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            iprot->readListBegin(_etype117, _size114);
            this->columnIDs.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += iprot->readI64(this->columnIDs[_i118]);
            }
            iprot->readListEnd();
          }
          this->__isset.columnIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Conflict::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Conflict");

  xfer += oprot->writeFieldBegin("details", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->details);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->columnIDs.size()));
    std::vector<ColumnID> ::const_iterator _iter119;
    for (_iter119 = this->columnIDs.begin(); _iter119 != this->columnIDs.end(); ++_iter119)
    {
      xfer += oprot->writeI64((*_iter119));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Conflict &a, Conflict &b) {
  using ::std::swap;
  swap(a.details, b.details);
  swap(a.columnIDs, b.columnIDs);
  swap(a.__isset, b.__isset);
}

const char* BeyondHistory::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t BeyondHistory::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t BeyondHistory::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minHistory);
          this->__isset.minHistory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BeyondHistory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BeyondHistory");

  xfer += oprot->writeFieldBegin("minHistory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minHistory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BeyondHistory &a, BeyondHistory &b) {
  using ::std::swap;
  swap(a.minHistory, b.minHistory);
  swap(a.__isset, b.__isset);
}

const char* ColumnRange::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t ColumnRange::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t ColumnRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_from = false;
  bool isset_to = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->from);
          isset_from = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->to);
          isset_to = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_from)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_to)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnRange");

  xfer += oprot->writeFieldBegin("from", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->from);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->to);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnRange &a, ColumnRange &b) {
  using ::std::swap;
  swap(a.from, b.from);
  swap(a.to, b.to);
}

const char* GetWritesResult::ascii_fingerprint = "F578B019C405B80D4EC8B7E62DE4AAEF";
const uint8_t GetWritesResult::binary_fingerprint[16] = {0xF5,0x78,0xB0,0x19,0xC4,0x05,0xB8,0x0D,0x4E,0xC8,0xB7,0xE6,0x2D,0xE4,0xAA,0xEF};

uint32_t GetWritesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_minFrom = false;
  bool isset_maxTo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->writes.read(iprot);
          this->__isset.writes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minFrom);
          isset_minFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxTo);
          isset_maxTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_minFrom)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetWritesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GetWritesResult");

  if (this->__isset.writes) {
    xfer += oprot->writeFieldBegin("writes", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->writes.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("minFrom", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->minFrom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTo", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->maxTo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetWritesResult &a, GetWritesResult &b) {
  using ::std::swap;
  swap(a.writes, b.writes);
  swap(a.minFrom, b.minFrom);
  swap(a.maxTo, b.maxTo);
  swap(a.__isset, b.__isset);
}

const char* StoreStatus::ascii_fingerprint = "9C2AEBD7AD53067E75E4507762FC4213";
const uint8_t StoreStatus::binary_fingerprint[16] = {0x9C,0x2A,0xEB,0xD7,0xAD,0x53,0x06,0x7E,0x75,0xE4,0x50,0x77,0x62,0xFC,0x42,0x13};

uint32_t StoreStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->LastCheckpoints.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _ktype121;
            ::apache::thrift::protocol::TType _vtype122;
            iprot->readMapBegin(_ktype121, _vtype122, _size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              ColumnID _key125;
              xfer += iprot->readI64(_key125);
              Revision& _val126 = this->LastCheckpoints[_key125];
              xfer += iprot->readI64(_val126);
            }
            iprot->readMapEnd();
          }
          this->__isset.LastCheckpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->beganCheckpoints.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            iprot->readSetBegin(_etype130, _size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              ColumnID _elem132;
              xfer += iprot->readI64(_elem132);
              this->beganCheckpoints.insert(_elem132);
            }
            iprot->readSetEnd();
          }
          this->__isset.beganCheckpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->LatestRevisions.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _ktype134;
            ::apache::thrift::protocol::TType _vtype135;
            iprot->readMapBegin(_ktype134, _vtype135, _size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              ColumnID _key138;
              xfer += iprot->readI64(_key138);
              Revision& _val139 = this->LatestRevisions[_key138];
              xfer += iprot->readI64(_val139);
            }
            iprot->readMapEnd();
          }
          this->__isset.LatestRevisions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StoreStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StoreStatus");

  xfer += oprot->writeFieldBegin("LastCheckpoints", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->LastCheckpoints.size()));
    std::map<ColumnID, Revision> ::const_iterator _iter140;
    for (_iter140 = this->LastCheckpoints.begin(); _iter140 != this->LastCheckpoints.end(); ++_iter140)
    {
      xfer += oprot->writeI64(_iter140->first);
      xfer += oprot->writeI64(_iter140->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("beganCheckpoints", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->beganCheckpoints.size()));
    std::set<ColumnID> ::const_iterator _iter141;
    for (_iter141 = this->beganCheckpoints.begin(); _iter141 != this->beganCheckpoints.end(); ++_iter141)
    {
      xfer += oprot->writeI64((*_iter141));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LatestRevisions", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->LatestRevisions.size()));
    std::map<ColumnID, Revision> ::const_iterator _iter142;
    for (_iter142 = this->LatestRevisions.begin(); _iter142 != this->LatestRevisions.end(); ++_iter142)
    {
      xfer += oprot->writeI64(_iter142->first);
      xfer += oprot->writeI64(_iter142->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StoreStatus &a, StoreStatus &b) {
  using ::std::swap;
  swap(a.LastCheckpoints, b.LastCheckpoints);
  swap(a.beganCheckpoints, b.beganCheckpoints);
  swap(a.LatestRevisions, b.LatestRevisions);
  swap(a.__isset, b.__isset);
}

}} // namespace
