/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Fastore_types.h"

#include <algorithm>

namespace fastore {

int _kRepositoryStatusValues[] = {
  RepositoryStatus::Loading,
  RepositoryStatus::Unloading,
  RepositoryStatus::Online,
  RepositoryStatus::Checkpointing
};
const char* _kRepositoryStatusNames[] = {
  "Loading",
  "Unloading",
  "Online",
  "Checkpointing"
};
const std::map<int, const char*> _RepositoryStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kRepositoryStatusValues, _kRepositoryStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHostStatusValues[] = {
  HostStatus::Offline,
  HostStatus::Online,
  HostStatus::Unreachable
};
const char* _kHostStatusNames[] = {
  "Offline",
  "Online",
  "Unreachable"
};
const std::map<int, const char*> _HostStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kHostStatusValues, _kHostStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockModeValues[] = {
  LockMode::Read,
  LockMode::Write
};
const char* _kLockModeNames[] = {
  "Read",
  "Write"
};
const std::map<int, const char*> _LockMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLockModeValues, _kLockModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Host::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t Host::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t Host::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ID);
          this->__isset.ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Address);
          this->__isset.Address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Host::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Host");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Address", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Host &a, Host &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Address, b.Address);
  swap(a.__isset, b.__isset);
}

const char* Repository::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t Repository::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t Repository::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnID);
          this->__isset.columnID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hostID);
          this->__isset.hostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Repository::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Repository");

  xfer += oprot->writeFieldBegin("columnID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->columnID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostID", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->hostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Repository &a, Repository &b) {
  using ::std::swap;
  swap(a.columnID, b.columnID);
  swap(a.hostID, b.hostID);
  swap(a.__isset, b.__isset);
}

const char* Topology::ascii_fingerprint = "D087BB3015A7C1BA44729FFF8D9C4426";
const uint8_t Topology::binary_fingerprint[16] = {0xD0,0x87,0xBB,0x30,0x15,0xA7,0xC1,0xBA,0x44,0x72,0x9F,0xFF,0x8D,0x9C,0x44,0x26};

uint32_t Topology::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ID);
          this->__isset.ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->Hosts.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readSetBegin(_etype3, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              Host _elem5;
              xfer += _elem5.read(iprot);
              this->Hosts.insert(_elem5);
            }
            iprot->readSetEnd();
          }
          this->__isset.Hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->Repositories.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            iprot->readSetBegin(_etype9, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              Repository _elem11;
              xfer += _elem11.read(iprot);
              this->Repositories.insert(_elem11);
            }
            iprot->readSetEnd();
          }
          this->__isset.Repositories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Topology::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Topology");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Hosts", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Hosts.size()));
    std::set<Host> ::const_iterator _iter12;
    for (_iter12 = this->Hosts.begin(); _iter12 != this->Hosts.end(); ++_iter12)
    {
      xfer += (*_iter12).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Repositories", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Repositories.size()));
    std::set<Repository> ::const_iterator _iter13;
    for (_iter13 = this->Repositories.begin(); _iter13 != this->Repositories.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Topology &a, Topology &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Hosts, b.Hosts);
  swap(a.Repositories, b.Repositories);
  swap(a.__isset, b.__isset);
}

const char* TopologyResult::ascii_fingerprint = "9EE0432C90FEA50EA66B7F2398815ABF";
const uint8_t TopologyResult::binary_fingerprint[16] = {0x9E,0xE0,0x43,0x2C,0x90,0xFE,0xA5,0x0E,0xA6,0x6B,0x7F,0x23,0x98,0x81,0x5A,0xBF};

uint32_t TopologyResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topology.read(iprot);
          this->__isset.topology = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopologyResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopologyResult");

  xfer += oprot->writeFieldBegin("topology", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->topology.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TopologyResult &a, TopologyResult &b) {
  using ::std::swap;
  swap(a.topology, b.topology);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

const char* HostReport::ascii_fingerprint = "7402C27C789620E471CF3FE2CB95E6AF";
const uint8_t HostReport::binary_fingerprint[16] = {0x74,0x02,0xC2,0x7C,0x78,0x96,0x20,0xE4,0x71,0xCF,0x3F,0xE2,0xCB,0x95,0xE6,0xAF};

uint32_t HostReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->Status = (HostStatus::type)ecast14;
          this->__isset.Status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->RepositoryStatus.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _ktype16;
            ::apache::thrift::protocol::TType _vtype17;
            iprot->readMapBegin(_ktype16, _vtype17, _size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              ColumnID _key20;
              xfer += iprot->readI32(_key20);
              RepositoryStatus::type& _val21 = this->RepositoryStatus[_key20];
              int32_t ecast22;
              xfer += iprot->readI32(ecast22);
              _val21 = (RepositoryStatus::type)ecast22;
            }
            iprot->readMapEnd();
          }
          this->__isset.RepositoryStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HostReport");

  xfer += oprot->writeFieldBegin("Status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->Status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RepositoryStatus", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->RepositoryStatus.size()));
    std::map<ColumnID, RepositoryStatus::type> ::const_iterator _iter23;
    for (_iter23 = this->RepositoryStatus.begin(); _iter23 != this->RepositoryStatus.end(); ++_iter23)
    {
      xfer += oprot->writeI32(_iter23->first);
      xfer += oprot->writeI32((int32_t)_iter23->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostReport &a, HostReport &b) {
  using ::std::swap;
  swap(a.Status, b.Status);
  swap(a.RepositoryStatus, b.RepositoryStatus);
  swap(a.__isset, b.__isset);
}

const char* TopologyReport::ascii_fingerprint = "E6AEC4F867448704EF06F6B449656C5E";
const uint8_t TopologyReport::binary_fingerprint[16] = {0xE6,0xAE,0xC4,0xF8,0x67,0x44,0x87,0x04,0xEF,0x06,0xF6,0xB4,0x49,0x65,0x6C,0x5E};

uint32_t TopologyReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->topologyID);
          this->__isset.topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Hosts.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              HostID _key29;
              xfer += iprot->readI32(_key29);
              HostReport& _val30 = this->Hosts[_key29];
              xfer += _val30.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.Hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopologyReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopologyReport");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Hosts", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Hosts.size()));
    std::map<HostID, HostReport> ::const_iterator _iter31;
    for (_iter31 = this->Hosts.begin(); _iter31 != this->Hosts.end(); ++_iter31)
    {
      xfer += oprot->writeI32(_iter31->first);
      xfer += _iter31->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TopologyReport &a, TopologyReport &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.Hosts, b.Hosts);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

const char* TransactionID::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TransactionID::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TransactionID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->Key);
          this->__isset.Key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransactionID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TransactionID");

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Key", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->Key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionID &a, TransactionID &b) {
  using ::std::swap;
  swap(a.revision, b.revision);
  swap(a.Key, b.Key);
  swap(a.__isset, b.__isset);
}

const char* Include::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t Include::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t Include::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->RowID);
          this->__isset.RowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Include::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Include");

  xfer += oprot->writeFieldBegin("RowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->RowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->Value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Include &a, Include &b) {
  using ::std::swap;
  swap(a.RowID, b.RowID);
  swap(a.Value, b.Value);
  swap(a.__isset, b.__isset);
}

const char* Exclude::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t Exclude::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t Exclude::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->RowID);
          this->__isset.RowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exclude::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Exclude");

  xfer += oprot->writeFieldBegin("RowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->RowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exclude &a, Exclude &b) {
  using ::std::swap;
  swap(a.RowID, b.RowID);
  swap(a.__isset, b.__isset);
}

const char* ColumnWrites::ascii_fingerprint = "0A6B3139A69DBA9DBD4F4688E49423B6";
const uint8_t ColumnWrites::binary_fingerprint[16] = {0x0A,0x6B,0x31,0x39,0xA6,0x9D,0xBA,0x9D,0xBD,0x4F,0x46,0x88,0xE4,0x94,0x23,0xB6};

uint32_t ColumnWrites::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Includes.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            iprot->readListBegin(_etype35, _size32);
            this->Includes.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->Includes[_i36].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.Includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Excludes.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            iprot->readListBegin(_etype40, _size37);
            this->Excludes.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->Excludes[_i41].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.Excludes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnWrites::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnWrites");

  xfer += oprot->writeFieldBegin("Includes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Includes.size()));
    std::vector<Include> ::const_iterator _iter42;
    for (_iter42 = this->Includes.begin(); _iter42 != this->Includes.end(); ++_iter42)
    {
      xfer += (*_iter42).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Excludes", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Excludes.size()));
    std::vector<Exclude> ::const_iterator _iter43;
    for (_iter43 = this->Excludes.begin(); _iter43 != this->Excludes.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnWrites &a, ColumnWrites &b) {
  using ::std::swap;
  swap(a.Includes, b.Includes);
  swap(a.Excludes, b.Excludes);
  swap(a.__isset, b.__isset);
}

const char* Statistic::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t Statistic::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t Statistic::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->Total);
          this->__isset.Total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->Unique);
          this->__isset.Unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Statistic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Statistic");

  xfer += oprot->writeFieldBegin("Total", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->Total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Unique", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->Unique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Statistic &a, Statistic &b) {
  using ::std::swap;
  swap(a.Total, b.Total);
  swap(a.Unique, b.Unique);
  swap(a.__isset, b.__isset);
}

const char* RangeBound::ascii_fingerprint = "9D71179D9CC54C80954B5F64B2A9E947";
const uint8_t RangeBound::binary_fingerprint[16] = {0x9D,0x71,0x17,0x9D,0x9C,0xC5,0x4C,0x80,0x95,0x4B,0x5F,0x64,0xB2,0xA9,0xE9,0x47};

uint32_t RangeBound::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->Inclusive);
          this->__isset.Inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->RowID);
          this->__isset.RowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RangeBound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeBound");

  xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->Value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Inclusive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->Inclusive);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.RowID) {
    xfer += oprot->writeFieldBegin("RowID", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->RowID);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeBound &a, RangeBound &b) {
  using ::std::swap;
  swap(a.Value, b.Value);
  swap(a.Inclusive, b.Inclusive);
  swap(a.RowID, b.RowID);
  swap(a.__isset, b.__isset);
}

const char* RangeRequest::ascii_fingerprint = "6DA53D6AD417E92FAC26EBB9A3A4F5BB";
const uint8_t RangeRequest::binary_fingerprint[16] = {0x6D,0xA5,0x3D,0x6A,0xD4,0x17,0xE9,0x2F,0xAC,0x26,0xEB,0xB9,0xA3,0xA4,0xF5,0xBB};

uint32_t RangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Limit);
          this->__isset.Limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->Ascending);
          this->__isset.Ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Start.read(iprot);
          this->__isset.Start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->End.read(iprot);
          this->__isset.End = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeRequest");

  xfer += oprot->writeFieldBegin("Limit", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->Limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Ascending", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->Ascending);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Start) {
    xfer += oprot->writeFieldBegin("Start", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->Start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.End) {
    xfer += oprot->writeFieldBegin("End", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->End.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeRequest &a, RangeRequest &b) {
  using ::std::swap;
  swap(a.Limit, b.Limit);
  swap(a.Ascending, b.Ascending);
  swap(a.Start, b.Start);
  swap(a.End, b.End);
  swap(a.__isset, b.__isset);
}

const char* ValueRows::ascii_fingerprint = "25702B8D5E28AA39160F267DABBC8446";
const uint8_t ValueRows::binary_fingerprint[16] = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

uint32_t ValueRows::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RowIDs.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            iprot->readListBegin(_etype47, _size44);
            this->RowIDs.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += iprot->readBinary(this->RowIDs[_i48]);
            }
            iprot->readListEnd();
          }
          this->__isset.RowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ValueRows::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ValueRows");

  xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->Value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RowIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RowIDs.size()));
    std::vector<std::string> ::const_iterator _iter49;
    for (_iter49 = this->RowIDs.begin(); _iter49 != this->RowIDs.end(); ++_iter49)
    {
      xfer += oprot->writeBinary((*_iter49));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ValueRows &a, ValueRows &b) {
  using ::std::swap;
  swap(a.Value, b.Value);
  swap(a.RowIDs, b.RowIDs);
  swap(a.__isset, b.__isset);
}

const char* RangeResult::ascii_fingerprint = "35701C18CAAD9A6D5379929C792CFFB9";
const uint8_t RangeResult::binary_fingerprint[16] = {0x35,0x70,0x1C,0x18,0xCA,0xAD,0x9A,0x6D,0x53,0x79,0x92,0x9C,0x79,0x2C,0xFF,0xB9};

uint32_t RangeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueRowsList.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            iprot->readListBegin(_etype53, _size50);
            this->valueRowsList.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += this->valueRowsList[_i54].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.valueRowsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->EndOfRange);
          this->__isset.EndOfRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->BeginOfRange);
          this->__isset.BeginOfRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RangeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeResult");

  xfer += oprot->writeFieldBegin("valueRowsList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->valueRowsList.size()));
    std::vector<ValueRows> ::const_iterator _iter55;
    for (_iter55 = this->valueRowsList.begin(); _iter55 != this->valueRowsList.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EndOfRange", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->EndOfRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BeginOfRange", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->BeginOfRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeResult &a, RangeResult &b) {
  using ::std::swap;
  swap(a.valueRowsList, b.valueRowsList);
  swap(a.EndOfRange, b.EndOfRange);
  swap(a.BeginOfRange, b.BeginOfRange);
  swap(a.__isset, b.__isset);
}

const char* Query::ascii_fingerprint = "EC0678E28E5088F474E56302FF4C2884";
const uint8_t Query::binary_fingerprint[16] = {0xEC,0x06,0x78,0xE2,0x8E,0x50,0x88,0xF4,0x74,0xE5,0x63,0x02,0xFF,0x4C,0x28,0x84};

uint32_t Query::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RowIDs.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            iprot->readListBegin(_etype59, _size56);
            this->RowIDs.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += iprot->readBinary(this->RowIDs[_i60]);
            }
            iprot->readListEnd();
          }
          this->__isset.RowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Ranges.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            iprot->readListBegin(_etype64, _size61);
            this->Ranges.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += this->Ranges[_i65].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.Ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Query::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Query");

  xfer += oprot->writeFieldBegin("RowIDs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RowIDs.size()));
    std::vector<std::string> ::const_iterator _iter66;
    for (_iter66 = this->RowIDs.begin(); _iter66 != this->RowIDs.end(); ++_iter66)
    {
      xfer += oprot->writeBinary((*_iter66));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Ranges.size()));
    std::vector<RangeRequest> ::const_iterator _iter67;
    for (_iter67 = this->Ranges.begin(); _iter67 != this->Ranges.end(); ++_iter67)
    {
      xfer += (*_iter67).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Query &a, Query &b) {
  using ::std::swap;
  swap(a.RowIDs, b.RowIDs);
  swap(a.Ranges, b.Ranges);
  swap(a.__isset, b.__isset);
}

const char* Answer::ascii_fingerprint = "0EF26ABE5434A4F3B55562D977866E0F";
const uint8_t Answer::binary_fingerprint[16] = {0x0E,0xF2,0x6A,0xBE,0x54,0x34,0xA4,0xF3,0xB5,0x55,0x62,0xD9,0x77,0x86,0x6E,0x0F};

uint32_t Answer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RowIDValues.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            iprot->readListBegin(_etype71, _size68);
            this->RowIDValues.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += iprot->readBinary(this->RowIDValues[_i72]);
            }
            iprot->readListEnd();
          }
          this->__isset.RowIDValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RangeValues.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            iprot->readListBegin(_etype76, _size73);
            this->RangeValues.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->RangeValues[_i77].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.RangeValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Answer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Answer");

  xfer += oprot->writeFieldBegin("RowIDValues", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RowIDValues.size()));
    std::vector<std::string> ::const_iterator _iter78;
    for (_iter78 = this->RowIDValues.begin(); _iter78 != this->RowIDValues.end(); ++_iter78)
    {
      xfer += oprot->writeBinary((*_iter78));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RangeValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->RangeValues.size()));
    std::vector<RangeResult> ::const_iterator _iter79;
    for (_iter79 = this->RangeValues.begin(); _iter79 != this->RangeValues.end(); ++_iter79)
    {
      xfer += (*_iter79).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Answer &a, Answer &b) {
  using ::std::swap;
  swap(a.RowIDValues, b.RowIDValues);
  swap(a.RangeValues, b.RangeValues);
  swap(a.__isset, b.__isset);
}

const char* ReadResults::ascii_fingerprint = "35E1DBCF381709B9ECBA674B21C87C14";
const uint8_t ReadResults::binary_fingerprint[16] = {0x35,0xE1,0xDB,0xCF,0x38,0x17,0x09,0xB9,0xEC,0xBA,0x67,0x4B,0x21,0xC8,0x7C,0x14};

uint32_t ReadResults::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Answers.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _ktype81;
            ::apache::thrift::protocol::TType _vtype82;
            iprot->readMapBegin(_ktype81, _vtype82, _size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              ColumnID _key85;
              xfer += iprot->readI32(_key85);
              Answer& _val86 = this->Answers[_key85];
              xfer += _val86.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.Answers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReadResults::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReadResults");

  xfer += oprot->writeFieldBegin("Answers", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Answers.size()));
    std::map<ColumnID, Answer> ::const_iterator _iter87;
    for (_iter87 = this->Answers.begin(); _iter87 != this->Answers.end(); ++_iter87)
    {
      xfer += oprot->writeI32(_iter87->first);
      xfer += _iter87->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadResults &a, ReadResults &b) {
  using ::std::swap;
  swap(a.Answers, b.Answers);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

const char* NotLatest::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t NotLatest::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t NotLatest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->Latest);
          this->__isset.Latest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotLatest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotLatest");

  xfer += oprot->writeFieldBegin("Latest", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->Latest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotLatest &a, NotLatest &b) {
  using ::std::swap;
  swap(a.Latest, b.Latest);
  swap(a.__isset, b.__isset);
}

const char* Conflict::ascii_fingerprint = "920F6571EE6C0CF61556A788D6042213";
const uint8_t Conflict::binary_fingerprint[16] = {0x92,0x0F,0x65,0x71,0xEE,0x6C,0x0C,0xF6,0x15,0x56,0xA7,0x88,0xD6,0x04,0x22,0x13};

uint32_t Conflict::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Details);
          this->__isset.Details = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ColumnIDs.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            iprot->readListBegin(_etype91, _size88);
            this->ColumnIDs.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += iprot->readI32(this->ColumnIDs[_i92]);
            }
            iprot->readListEnd();
          }
          this->__isset.ColumnIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Conflict::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Conflict");

  xfer += oprot->writeFieldBegin("Details", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Details);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ColumnIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->ColumnIDs.size()));
    std::vector<ColumnID> ::const_iterator _iter93;
    for (_iter93 = this->ColumnIDs.begin(); _iter93 != this->ColumnIDs.end(); ++_iter93)
    {
      xfer += oprot->writeI32((*_iter93));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Conflict &a, Conflict &b) {
  using ::std::swap;
  swap(a.Details, b.Details);
  swap(a.ColumnIDs, b.ColumnIDs);
  swap(a.__isset, b.__isset);
}

const char* BeyondHistory::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t BeyondHistory::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t BeyondHistory::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->MinHistory);
          this->__isset.MinHistory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BeyondHistory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BeyondHistory");

  xfer += oprot->writeFieldBegin("MinHistory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->MinHistory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BeyondHistory &a, BeyondHistory &b) {
  using ::std::swap;
  swap(a.MinHistory, b.MinHistory);
  swap(a.__isset, b.__isset);
}

const char* LockExpired::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t LockExpired::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t LockExpired::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockID);
          this->__isset.lockID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockExpired::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockExpired");

  xfer += oprot->writeFieldBegin("lockID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockExpired &a, LockExpired &b) {
  using ::std::swap;
  swap(a.lockID, b.lockID);
  swap(a.__isset, b.__isset);
}

const char* LockTimedOut::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t LockTimedOut::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t LockTimedOut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockTimedOut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockTimedOut");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockTimedOut &a, LockTimedOut &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

} // namespace
