// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>


#include "Service.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::fastore;

class ServiceHandler : virtual public ServiceIf {
 public:
  ServiceHandler() {
    // Your initialization goes here
  }

  void GetTopology(TopologyResult& _return) {
    // Your implementation goes here
    printf("GetTopology\n");
  }

  Revision PrepareTopology(const TransactionID& transactionID, const Topology& topology) {
    // Your implementation goes here
    printf("PrepareTopology\n");

	return 0;
  }

  void CommitTopology(const TransactionID& transactionID) {
    // Your implementation goes here
    printf("CommitTopology\n");
  }

  void RollbackTopology(const TransactionID& transactionID) {
    // Your implementation goes here
    printf("RollbackTopology\n");
  }

  void GetTopologyReport(TopologyReport& _return) {
    // Your implementation goes here
    printf("GetTopologyReport\n");
  }

  void GetReport(HostReport& _return) {
    // Your implementation goes here
    printf("GetReport\n");
  }

  Revision Prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads) {
    // Your implementation goes here
    printf("Prepare\n");

	return 0;
  }

  void Apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes) {
    // Your implementation goes here
    printf("Apply\n");
  }

  void Commit(const TransactionID& transactionID) {
    // Your implementation goes here
    printf("Commit\n");
  }

  void Rollback(const TransactionID& transactionID) {
    // Your implementation goes here
    printf("Rollback\n");
  }

  void Flush(const TransactionID& transactionID) {
    // Your implementation goes here
    printf("Flush\n");
  }

  bool DoesConflict(const Reads& reads, const Revision source, const Revision target) {
    // Your implementation goes here
    printf("DoesConflict\n");

	return false;
  }

  void Update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads) {
    // Your implementation goes here
    printf("Update\n");
  }

  void Transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target) {
    // Your implementation goes here
    printf("Transgrade\n");
  }

  LockID AcquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) {
    // Your implementation goes here
    printf("AcquireLock\n");

	return 0;
  }

  void KeepLock(const LockID lockID) {
    // Your implementation goes here
    printf("KeepLock\n");
  }

  void EscalateLock(const LockID lockID, const LockTimeout timeout) {
    // Your implementation goes here
    printf("EscalateLock\n");
  }

  void ReleaseLock(const LockID lockID) {
    // Your implementation goes here
    printf("ReleaseLock\n");
  }

  void Query(ReadResults& _return, const Queries& queries) {
    // Your implementation goes here
    printf("Query\n");
  }

  void GetStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs) {
    // Your implementation goes here
    printf("GetStatistics\n");
  }

};

int main(int argc, char **argv) {

	WORD wVersionRequested;
	WSADATA wsaData;
	int err;

	/* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
    wVersionRequested = MAKEWORD(2, 2);

    err = WSAStartup(wVersionRequested, &wsaData);
    if (err != 0) {
        /* Tell the user that we could not find a usable */
        /* Winsock DLL.                                  */
        printf("WSAStartup failed with error: %d\n", err);
        return 1;
    }

	/* Confirm that the WinSock DLL supports 2.2.*/
	/* Note that if the DLL supports versions greater    */
	/* than 2.2 in addition to 2.2, it will still return */
	/* 2.2 in wVersion since that is the version we      */
	/* requested.                                        */

    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
        /* Tell the user that we could not find a usable */
        /* WinSock DLL.                                  */
        printf("Could not find a usable version of Winsock.dll\n");
        WSACleanup();
        return 1;
    }
    else
        printf("The Winsock 2.2 dll was found okay\n");


	int port = 9090;
	shared_ptr<ServiceHandler> handler(new ServiceHandler());
	shared_ptr<TProcessor> processor(new ServiceProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();

	WSACleanup();

	return 0;
}

