/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Service_H
#define Service_H

#include <thrift/TDispatchProcessor.h>
#include "Fastore_types.h"

namespace fastore {

class ServiceIf {
 public:
  virtual ~ServiceIf() {}
  virtual void GetTopology(TopologyResult& _return) = 0;
  virtual Revision PrepareTopology(const TransactionID& transactionID, const Topology& topology) = 0;
  virtual void CommitTopology(const TransactionID& transactionID) = 0;
  virtual void RollbackTopology(const TransactionID& transactionID) = 0;
  virtual void GetTopologyReport(TopologyReport& _return) = 0;
  virtual void GetReport(HostReport& _return) = 0;
  virtual Revision Prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads) = 0;
  virtual void Apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes) = 0;
  virtual void Commit(const TransactionID& transactionID) = 0;
  virtual void Rollback(const TransactionID& transactionID) = 0;
  virtual void Flush(const TransactionID& transactionID) = 0;
  virtual bool DoesConflict(const Reads& reads, const Revision source, const Revision target) = 0;
  virtual void Update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads) = 0;
  virtual void Transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target) = 0;
  virtual LockID AcquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) = 0;
  virtual void KeepLock(const LockID lockID) = 0;
  virtual void EscalateLock(const LockID lockID, const LockTimeout timeout) = 0;
  virtual void ReleaseLock(const LockID lockID) = 0;
  virtual void Query(ReadResults& _return, const Queries& queries) = 0;
  virtual void GetStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs) = 0;
};

class ServiceIfFactory {
 public:
  typedef ServiceIf Handler;

  virtual ~ServiceIfFactory() {}

  virtual ServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ServiceIf* /* handler */) = 0;
};

class ServiceIfSingletonFactory : virtual public ServiceIfFactory {
 public:
  ServiceIfSingletonFactory(const boost::shared_ptr<ServiceIf>& iface) : iface_(iface) {}
  virtual ~ServiceIfSingletonFactory() {}

  virtual ServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<ServiceIf> iface_;
};

class ServiceNull : virtual public ServiceIf {
 public:
  virtual ~ServiceNull() {}
  void GetTopology(TopologyResult& /* _return */) {
    return;
  }
  Revision PrepareTopology(const TransactionID& /* transactionID */, const Topology& /* topology */) {
    Revision _return = 0;
    return _return;
  }
  void CommitTopology(const TransactionID& /* transactionID */) {
    return;
  }
  void RollbackTopology(const TransactionID& /* transactionID */) {
    return;
  }
  void GetTopologyReport(TopologyReport& /* _return */) {
    return;
  }
  void GetReport(HostReport& /* _return */) {
    return;
  }
  Revision Prepare(const TransactionID& /* transactionID */, const Writes& /* writes */, const Reads& /* reads */) {
    Revision _return = 0;
    return _return;
  }
  void Apply(TransactionID& /* _return */, const TransactionID& /* transactionID */, const Writes& /* writes */) {
    return;
  }
  void Commit(const TransactionID& /* transactionID */) {
    return;
  }
  void Rollback(const TransactionID& /* transactionID */) {
    return;
  }
  void Flush(const TransactionID& /* transactionID */) {
    return;
  }
  bool DoesConflict(const Reads& /* reads */, const Revision /* source */, const Revision /* target */) {
    bool _return = false;
    return _return;
  }
  void Update(TransactionID& /* _return */, const TransactionID& /* transactionID */, const Writes& /* writes */, const Reads& /* reads */) {
    return;
  }
  void Transgrade(Reads& /* _return */, const Reads& /* reads */, const Revision /* source */, const Revision /* target */) {
    return;
  }
  LockID AcquireLock(const LockName& /* name */, const LockMode::type /* mode */, const LockTimeout /* timeout */) {
    LockID _return = 0;
    return _return;
  }
  void KeepLock(const LockID /* lockID */) {
    return;
  }
  void EscalateLock(const LockID /* lockID */, const LockTimeout /* timeout */) {
    return;
  }
  void ReleaseLock(const LockID /* lockID */) {
    return;
  }
  void Query(ReadResults& /* _return */, const Queries& /* queries */) {
    return;
  }
  void GetStatistics(std::vector<Statistic> & /* _return */, const std::vector<ColumnID> & /* columnIDs */) {
    return;
  }
};


class Service_GetTopology_args {
 public:

  Service_GetTopology_args() {
  }

  virtual ~Service_GetTopology_args() throw() {}


  bool operator == (const Service_GetTopology_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_GetTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_GetTopology_pargs {
 public:


  virtual ~Service_GetTopology_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetTopology_result__isset {
  _Service_GetTopology_result__isset() : success(false) {}
  bool success;
} _Service_GetTopology_result__isset;

class Service_GetTopology_result {
 public:

  Service_GetTopology_result() {
  }

  virtual ~Service_GetTopology_result() throw() {}

  TopologyResult success;

  _Service_GetTopology_result__isset __isset;

  void __set_success(const TopologyResult& val) {
    success = val;
  }

  bool operator == (const Service_GetTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_GetTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetTopology_presult__isset {
  _Service_GetTopology_presult__isset() : success(false) {}
  bool success;
} _Service_GetTopology_presult__isset;

class Service_GetTopology_presult {
 public:


  virtual ~Service_GetTopology_presult() throw() {}

  TopologyResult* success;

  _Service_GetTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_PrepareTopology_args__isset {
  _Service_PrepareTopology_args__isset() : transactionID(false), topology(false) {}
  bool transactionID;
  bool topology;
} _Service_PrepareTopology_args__isset;

class Service_PrepareTopology_args {
 public:

  Service_PrepareTopology_args() {
  }

  virtual ~Service_PrepareTopology_args() throw() {}

  TransactionID transactionID;
  Topology topology;

  _Service_PrepareTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_topology(const Topology& val) {
    topology = val;
  }

  bool operator == (const Service_PrepareTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(topology == rhs.topology))
      return false;
    return true;
  }
  bool operator != (const Service_PrepareTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_PrepareTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_PrepareTopology_pargs {
 public:


  virtual ~Service_PrepareTopology_pargs() throw() {}

  const TransactionID* transactionID;
  const Topology* topology;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_PrepareTopology_result__isset {
  _Service_PrepareTopology_result__isset() : success(false) {}
  bool success;
} _Service_PrepareTopology_result__isset;

class Service_PrepareTopology_result {
 public:

  Service_PrepareTopology_result() : success(0) {
  }

  virtual ~Service_PrepareTopology_result() throw() {}

  Revision success;

  _Service_PrepareTopology_result__isset __isset;

  void __set_success(const Revision val) {
    success = val;
  }

  bool operator == (const Service_PrepareTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_PrepareTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_PrepareTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_PrepareTopology_presult__isset {
  _Service_PrepareTopology_presult__isset() : success(false) {}
  bool success;
} _Service_PrepareTopology_presult__isset;

class Service_PrepareTopology_presult {
 public:


  virtual ~Service_PrepareTopology_presult() throw() {}

  Revision* success;

  _Service_PrepareTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_CommitTopology_args__isset {
  _Service_CommitTopology_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_CommitTopology_args__isset;

class Service_CommitTopology_args {
 public:

  Service_CommitTopology_args() {
  }

  virtual ~Service_CommitTopology_args() throw() {}

  TransactionID transactionID;

  _Service_CommitTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_CommitTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_CommitTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_CommitTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_CommitTopology_pargs {
 public:


  virtual ~Service_CommitTopology_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_CommitTopology_result {
 public:

  Service_CommitTopology_result() {
  }

  virtual ~Service_CommitTopology_result() throw() {}


  bool operator == (const Service_CommitTopology_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_CommitTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_CommitTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_CommitTopology_presult {
 public:


  virtual ~Service_CommitTopology_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_RollbackTopology_args__isset {
  _Service_RollbackTopology_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_RollbackTopology_args__isset;

class Service_RollbackTopology_args {
 public:

  Service_RollbackTopology_args() {
  }

  virtual ~Service_RollbackTopology_args() throw() {}

  TransactionID transactionID;

  _Service_RollbackTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_RollbackTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_RollbackTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_RollbackTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_RollbackTopology_pargs {
 public:


  virtual ~Service_RollbackTopology_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_RollbackTopology_result {
 public:

  Service_RollbackTopology_result() {
  }

  virtual ~Service_RollbackTopology_result() throw() {}


  bool operator == (const Service_RollbackTopology_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_RollbackTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_RollbackTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_RollbackTopology_presult {
 public:


  virtual ~Service_RollbackTopology_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Service_GetTopologyReport_args {
 public:

  Service_GetTopologyReport_args() {
  }

  virtual ~Service_GetTopologyReport_args() throw() {}


  bool operator == (const Service_GetTopologyReport_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_GetTopologyReport_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetTopologyReport_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_GetTopologyReport_pargs {
 public:


  virtual ~Service_GetTopologyReport_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetTopologyReport_result__isset {
  _Service_GetTopologyReport_result__isset() : success(false) {}
  bool success;
} _Service_GetTopologyReport_result__isset;

class Service_GetTopologyReport_result {
 public:

  Service_GetTopologyReport_result() {
  }

  virtual ~Service_GetTopologyReport_result() throw() {}

  TopologyReport success;

  _Service_GetTopologyReport_result__isset __isset;

  void __set_success(const TopologyReport& val) {
    success = val;
  }

  bool operator == (const Service_GetTopologyReport_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_GetTopologyReport_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetTopologyReport_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetTopologyReport_presult__isset {
  _Service_GetTopologyReport_presult__isset() : success(false) {}
  bool success;
} _Service_GetTopologyReport_presult__isset;

class Service_GetTopologyReport_presult {
 public:


  virtual ~Service_GetTopologyReport_presult() throw() {}

  TopologyReport* success;

  _Service_GetTopologyReport_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Service_GetReport_args {
 public:

  Service_GetReport_args() {
  }

  virtual ~Service_GetReport_args() throw() {}


  bool operator == (const Service_GetReport_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_GetReport_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetReport_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_GetReport_pargs {
 public:


  virtual ~Service_GetReport_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetReport_result__isset {
  _Service_GetReport_result__isset() : success(false) {}
  bool success;
} _Service_GetReport_result__isset;

class Service_GetReport_result {
 public:

  Service_GetReport_result() {
  }

  virtual ~Service_GetReport_result() throw() {}

  HostReport success;

  _Service_GetReport_result__isset __isset;

  void __set_success(const HostReport& val) {
    success = val;
  }

  bool operator == (const Service_GetReport_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_GetReport_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetReport_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetReport_presult__isset {
  _Service_GetReport_presult__isset() : success(false) {}
  bool success;
} _Service_GetReport_presult__isset;

class Service_GetReport_presult {
 public:


  virtual ~Service_GetReport_presult() throw() {}

  HostReport* success;

  _Service_GetReport_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Prepare_args__isset {
  _Service_Prepare_args__isset() : transactionID(false), writes(false), reads(false) {}
  bool transactionID;
  bool writes;
  bool reads;
} _Service_Prepare_args__isset;

class Service_Prepare_args {
 public:

  Service_Prepare_args() {
  }

  virtual ~Service_Prepare_args() throw() {}

  TransactionID transactionID;
  Writes writes;
  Reads reads;

  _Service_Prepare_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_writes(const Writes& val) {
    writes = val;
  }

  void __set_reads(const Reads& val) {
    reads = val;
  }

  bool operator == (const Service_Prepare_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(writes == rhs.writes))
      return false;
    if (!(reads == rhs.reads))
      return false;
    return true;
  }
  bool operator != (const Service_Prepare_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Prepare_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Prepare_pargs {
 public:


  virtual ~Service_Prepare_pargs() throw() {}

  const TransactionID* transactionID;
  const Writes* writes;
  const Reads* reads;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Prepare_result__isset {
  _Service_Prepare_result__isset() : success(false), notLatest(false) {}
  bool success;
  bool notLatest;
} _Service_Prepare_result__isset;

class Service_Prepare_result {
 public:

  Service_Prepare_result() : success(0) {
  }

  virtual ~Service_Prepare_result() throw() {}

  Revision success;
  NotLatest notLatest;

  _Service_Prepare_result__isset __isset;

  void __set_success(const Revision val) {
    success = val;
  }

  void __set_notLatest(const NotLatest& val) {
    notLatest = val;
  }

  bool operator == (const Service_Prepare_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(notLatest == rhs.notLatest))
      return false;
    return true;
  }
  bool operator != (const Service_Prepare_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Prepare_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Prepare_presult__isset {
  _Service_Prepare_presult__isset() : success(false), notLatest(false) {}
  bool success;
  bool notLatest;
} _Service_Prepare_presult__isset;

class Service_Prepare_presult {
 public:


  virtual ~Service_Prepare_presult() throw() {}

  Revision* success;
  NotLatest notLatest;

  _Service_Prepare_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Apply_args__isset {
  _Service_Apply_args__isset() : transactionID(false), writes(false) {}
  bool transactionID;
  bool writes;
} _Service_Apply_args__isset;

class Service_Apply_args {
 public:

  Service_Apply_args() {
  }

  virtual ~Service_Apply_args() throw() {}

  TransactionID transactionID;
  Writes writes;

  _Service_Apply_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_writes(const Writes& val) {
    writes = val;
  }

  bool operator == (const Service_Apply_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(writes == rhs.writes))
      return false;
    return true;
  }
  bool operator != (const Service_Apply_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Apply_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Apply_pargs {
 public:


  virtual ~Service_Apply_pargs() throw() {}

  const TransactionID* transactionID;
  const Writes* writes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Apply_result__isset {
  _Service_Apply_result__isset() : success(false) {}
  bool success;
} _Service_Apply_result__isset;

class Service_Apply_result {
 public:

  Service_Apply_result() {
  }

  virtual ~Service_Apply_result() throw() {}

  TransactionID success;

  _Service_Apply_result__isset __isset;

  void __set_success(const TransactionID& val) {
    success = val;
  }

  bool operator == (const Service_Apply_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_Apply_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Apply_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Apply_presult__isset {
  _Service_Apply_presult__isset() : success(false) {}
  bool success;
} _Service_Apply_presult__isset;

class Service_Apply_presult {
 public:


  virtual ~Service_Apply_presult() throw() {}

  TransactionID* success;

  _Service_Apply_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Commit_args__isset {
  _Service_Commit_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_Commit_args__isset;

class Service_Commit_args {
 public:

  Service_Commit_args() {
  }

  virtual ~Service_Commit_args() throw() {}

  TransactionID transactionID;

  _Service_Commit_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_Commit_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_Commit_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Commit_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Commit_pargs {
 public:


  virtual ~Service_Commit_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Commit_result {
 public:

  Service_Commit_result() {
  }

  virtual ~Service_Commit_result() throw() {}


  bool operator == (const Service_Commit_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_Commit_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Commit_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Commit_presult {
 public:


  virtual ~Service_Commit_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Rollback_args__isset {
  _Service_Rollback_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_Rollback_args__isset;

class Service_Rollback_args {
 public:

  Service_Rollback_args() {
  }

  virtual ~Service_Rollback_args() throw() {}

  TransactionID transactionID;

  _Service_Rollback_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_Rollback_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_Rollback_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Rollback_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Rollback_pargs {
 public:


  virtual ~Service_Rollback_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Rollback_result {
 public:

  Service_Rollback_result() {
  }

  virtual ~Service_Rollback_result() throw() {}


  bool operator == (const Service_Rollback_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_Rollback_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Rollback_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Rollback_presult {
 public:


  virtual ~Service_Rollback_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Flush_args__isset {
  _Service_Flush_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_Flush_args__isset;

class Service_Flush_args {
 public:

  Service_Flush_args() {
  }

  virtual ~Service_Flush_args() throw() {}

  TransactionID transactionID;

  _Service_Flush_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_Flush_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_Flush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Flush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Flush_pargs {
 public:


  virtual ~Service_Flush_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Flush_result {
 public:

  Service_Flush_result() {
  }

  virtual ~Service_Flush_result() throw() {}


  bool operator == (const Service_Flush_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_Flush_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Flush_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Flush_presult {
 public:


  virtual ~Service_Flush_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_DoesConflict_args__isset {
  _Service_DoesConflict_args__isset() : reads(false), source(false), target(false) {}
  bool reads;
  bool source;
  bool target;
} _Service_DoesConflict_args__isset;

class Service_DoesConflict_args {
 public:

  Service_DoesConflict_args() : source(0), target(0) {
  }

  virtual ~Service_DoesConflict_args() throw() {}

  Reads reads;
  Revision source;
  Revision target;

  _Service_DoesConflict_args__isset __isset;

  void __set_reads(const Reads& val) {
    reads = val;
  }

  void __set_source(const Revision val) {
    source = val;
  }

  void __set_target(const Revision val) {
    target = val;
  }

  bool operator == (const Service_DoesConflict_args & rhs) const
  {
    if (!(reads == rhs.reads))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(target == rhs.target))
      return false;
    return true;
  }
  bool operator != (const Service_DoesConflict_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_DoesConflict_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_DoesConflict_pargs {
 public:


  virtual ~Service_DoesConflict_pargs() throw() {}

  const Reads* reads;
  const Revision* source;
  const Revision* target;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_DoesConflict_result__isset {
  _Service_DoesConflict_result__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_DoesConflict_result__isset;

class Service_DoesConflict_result {
 public:

  Service_DoesConflict_result() : success(0) {
  }

  virtual ~Service_DoesConflict_result() throw() {}

  bool success;
  BeyondHistory beyondHistory;

  _Service_DoesConflict_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_beyondHistory(const BeyondHistory& val) {
    beyondHistory = val;
  }

  bool operator == (const Service_DoesConflict_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(beyondHistory == rhs.beyondHistory))
      return false;
    return true;
  }
  bool operator != (const Service_DoesConflict_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_DoesConflict_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_DoesConflict_presult__isset {
  _Service_DoesConflict_presult__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_DoesConflict_presult__isset;

class Service_DoesConflict_presult {
 public:


  virtual ~Service_DoesConflict_presult() throw() {}

  bool* success;
  BeyondHistory beyondHistory;

  _Service_DoesConflict_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Update_args__isset {
  _Service_Update_args__isset() : transactionID(false), writes(false), reads(false) {}
  bool transactionID;
  bool writes;
  bool reads;
} _Service_Update_args__isset;

class Service_Update_args {
 public:

  Service_Update_args() {
  }

  virtual ~Service_Update_args() throw() {}

  TransactionID transactionID;
  Writes writes;
  Reads reads;

  _Service_Update_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_writes(const Writes& val) {
    writes = val;
  }

  void __set_reads(const Reads& val) {
    reads = val;
  }

  bool operator == (const Service_Update_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(writes == rhs.writes))
      return false;
    if (!(reads == rhs.reads))
      return false;
    return true;
  }
  bool operator != (const Service_Update_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Update_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Update_pargs {
 public:


  virtual ~Service_Update_pargs() throw() {}

  const TransactionID* transactionID;
  const Writes* writes;
  const Reads* reads;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Update_result__isset {
  _Service_Update_result__isset() : success(false), conflict(false) {}
  bool success;
  bool conflict;
} _Service_Update_result__isset;

class Service_Update_result {
 public:

  Service_Update_result() {
  }

  virtual ~Service_Update_result() throw() {}

  TransactionID success;
  Conflict conflict;

  _Service_Update_result__isset __isset;

  void __set_success(const TransactionID& val) {
    success = val;
  }

  void __set_conflict(const Conflict& val) {
    conflict = val;
  }

  bool operator == (const Service_Update_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(conflict == rhs.conflict))
      return false;
    return true;
  }
  bool operator != (const Service_Update_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Update_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Update_presult__isset {
  _Service_Update_presult__isset() : success(false), conflict(false) {}
  bool success;
  bool conflict;
} _Service_Update_presult__isset;

class Service_Update_presult {
 public:


  virtual ~Service_Update_presult() throw() {}

  TransactionID* success;
  Conflict conflict;

  _Service_Update_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Transgrade_args__isset {
  _Service_Transgrade_args__isset() : reads(false), source(false), target(false) {}
  bool reads;
  bool source;
  bool target;
} _Service_Transgrade_args__isset;

class Service_Transgrade_args {
 public:

  Service_Transgrade_args() : source(0), target(0) {
  }

  virtual ~Service_Transgrade_args() throw() {}

  Reads reads;
  Revision source;
  Revision target;

  _Service_Transgrade_args__isset __isset;

  void __set_reads(const Reads& val) {
    reads = val;
  }

  void __set_source(const Revision val) {
    source = val;
  }

  void __set_target(const Revision val) {
    target = val;
  }

  bool operator == (const Service_Transgrade_args & rhs) const
  {
    if (!(reads == rhs.reads))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(target == rhs.target))
      return false;
    return true;
  }
  bool operator != (const Service_Transgrade_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Transgrade_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Transgrade_pargs {
 public:


  virtual ~Service_Transgrade_pargs() throw() {}

  const Reads* reads;
  const Revision* source;
  const Revision* target;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Transgrade_result__isset {
  _Service_Transgrade_result__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_Transgrade_result__isset;

class Service_Transgrade_result {
 public:

  Service_Transgrade_result() {
  }

  virtual ~Service_Transgrade_result() throw() {}

  Reads success;
  BeyondHistory beyondHistory;

  _Service_Transgrade_result__isset __isset;

  void __set_success(const Reads& val) {
    success = val;
  }

  void __set_beyondHistory(const BeyondHistory& val) {
    beyondHistory = val;
  }

  bool operator == (const Service_Transgrade_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(beyondHistory == rhs.beyondHistory))
      return false;
    return true;
  }
  bool operator != (const Service_Transgrade_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Transgrade_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Transgrade_presult__isset {
  _Service_Transgrade_presult__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_Transgrade_presult__isset;

class Service_Transgrade_presult {
 public:


  virtual ~Service_Transgrade_presult() throw() {}

  Reads* success;
  BeyondHistory beyondHistory;

  _Service_Transgrade_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_AcquireLock_args__isset {
  _Service_AcquireLock_args__isset() : name(false), mode(false), timeout(true) {}
  bool name;
  bool mode;
  bool timeout;
} _Service_AcquireLock_args__isset;

class Service_AcquireLock_args {
 public:

  Service_AcquireLock_args() : name(), mode((LockMode::type)0), timeout(1000) {
  }

  virtual ~Service_AcquireLock_args() throw() {}

  LockName name;
  LockMode::type mode;
  LockTimeout timeout;

  _Service_AcquireLock_args__isset __isset;

  void __set_name(const LockName& val) {
    name = val;
  }

  void __set_mode(const LockMode::type val) {
    mode = val;
  }

  void __set_timeout(const LockTimeout val) {
    timeout = val;
  }

  bool operator == (const Service_AcquireLock_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(mode == rhs.mode))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_AcquireLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_AcquireLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_AcquireLock_pargs {
 public:


  virtual ~Service_AcquireLock_pargs() throw() {}

  const LockName* name;
  const LockMode::type* mode;
  const LockTimeout* timeout;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_AcquireLock_result__isset {
  _Service_AcquireLock_result__isset() : success(false), timeout(false) {}
  bool success;
  bool timeout;
} _Service_AcquireLock_result__isset;

class Service_AcquireLock_result {
 public:

  Service_AcquireLock_result() : success(0) {
  }

  virtual ~Service_AcquireLock_result() throw() {}

  LockID success;
  LockTimedOut timeout;

  _Service_AcquireLock_result__isset __isset;

  void __set_success(const LockID val) {
    success = val;
  }

  void __set_timeout(const LockTimedOut& val) {
    timeout = val;
  }

  bool operator == (const Service_AcquireLock_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_AcquireLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_AcquireLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_AcquireLock_presult__isset {
  _Service_AcquireLock_presult__isset() : success(false), timeout(false) {}
  bool success;
  bool timeout;
} _Service_AcquireLock_presult__isset;

class Service_AcquireLock_presult {
 public:


  virtual ~Service_AcquireLock_presult() throw() {}

  LockID* success;
  LockTimedOut timeout;

  _Service_AcquireLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_KeepLock_args__isset {
  _Service_KeepLock_args__isset() : lockID(false) {}
  bool lockID;
} _Service_KeepLock_args__isset;

class Service_KeepLock_args {
 public:

  Service_KeepLock_args() : lockID(0) {
  }

  virtual ~Service_KeepLock_args() throw() {}

  LockID lockID;

  _Service_KeepLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  bool operator == (const Service_KeepLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    return true;
  }
  bool operator != (const Service_KeepLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_KeepLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_KeepLock_pargs {
 public:


  virtual ~Service_KeepLock_pargs() throw() {}

  const LockID* lockID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_KeepLock_result__isset {
  _Service_KeepLock_result__isset() : expired(false) {}
  bool expired;
} _Service_KeepLock_result__isset;

class Service_KeepLock_result {
 public:

  Service_KeepLock_result() {
  }

  virtual ~Service_KeepLock_result() throw() {}

  LockExpired expired;

  _Service_KeepLock_result__isset __isset;

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_KeepLock_result & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_KeepLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_KeepLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_KeepLock_presult__isset {
  _Service_KeepLock_presult__isset() : expired(false) {}
  bool expired;
} _Service_KeepLock_presult__isset;

class Service_KeepLock_presult {
 public:


  virtual ~Service_KeepLock_presult() throw() {}

  LockExpired expired;

  _Service_KeepLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_EscalateLock_args__isset {
  _Service_EscalateLock_args__isset() : lockID(false), timeout(true) {}
  bool lockID;
  bool timeout;
} _Service_EscalateLock_args__isset;

class Service_EscalateLock_args {
 public:

  Service_EscalateLock_args() : lockID(0), timeout(-1) {
  }

  virtual ~Service_EscalateLock_args() throw() {}

  LockID lockID;
  LockTimeout timeout;

  _Service_EscalateLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  void __set_timeout(const LockTimeout val) {
    timeout = val;
  }

  bool operator == (const Service_EscalateLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_EscalateLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_EscalateLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_EscalateLock_pargs {
 public:


  virtual ~Service_EscalateLock_pargs() throw() {}

  const LockID* lockID;
  const LockTimeout* timeout;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_EscalateLock_result__isset {
  _Service_EscalateLock_result__isset() : timeout(false), expired(false) {}
  bool timeout;
  bool expired;
} _Service_EscalateLock_result__isset;

class Service_EscalateLock_result {
 public:

  Service_EscalateLock_result() {
  }

  virtual ~Service_EscalateLock_result() throw() {}

  LockTimedOut timeout;
  LockExpired expired;

  _Service_EscalateLock_result__isset __isset;

  void __set_timeout(const LockTimedOut& val) {
    timeout = val;
  }

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_EscalateLock_result & rhs) const
  {
    if (!(timeout == rhs.timeout))
      return false;
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_EscalateLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_EscalateLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_EscalateLock_presult__isset {
  _Service_EscalateLock_presult__isset() : timeout(false), expired(false) {}
  bool timeout;
  bool expired;
} _Service_EscalateLock_presult__isset;

class Service_EscalateLock_presult {
 public:


  virtual ~Service_EscalateLock_presult() throw() {}

  LockTimedOut timeout;
  LockExpired expired;

  _Service_EscalateLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_ReleaseLock_args__isset {
  _Service_ReleaseLock_args__isset() : lockID(false) {}
  bool lockID;
} _Service_ReleaseLock_args__isset;

class Service_ReleaseLock_args {
 public:

  Service_ReleaseLock_args() : lockID(0) {
  }

  virtual ~Service_ReleaseLock_args() throw() {}

  LockID lockID;

  _Service_ReleaseLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  bool operator == (const Service_ReleaseLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    return true;
  }
  bool operator != (const Service_ReleaseLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_ReleaseLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_ReleaseLock_pargs {
 public:


  virtual ~Service_ReleaseLock_pargs() throw() {}

  const LockID* lockID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_ReleaseLock_result__isset {
  _Service_ReleaseLock_result__isset() : expired(false) {}
  bool expired;
} _Service_ReleaseLock_result__isset;

class Service_ReleaseLock_result {
 public:

  Service_ReleaseLock_result() {
  }

  virtual ~Service_ReleaseLock_result() throw() {}

  LockExpired expired;

  _Service_ReleaseLock_result__isset __isset;

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_ReleaseLock_result & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_ReleaseLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_ReleaseLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_ReleaseLock_presult__isset {
  _Service_ReleaseLock_presult__isset() : expired(false) {}
  bool expired;
} _Service_ReleaseLock_presult__isset;

class Service_ReleaseLock_presult {
 public:


  virtual ~Service_ReleaseLock_presult() throw() {}

  LockExpired expired;

  _Service_ReleaseLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_Query_args__isset {
  _Service_Query_args__isset() : queries(false) {}
  bool queries;
} _Service_Query_args__isset;

class Service_Query_args {
 public:

  Service_Query_args() {
  }

  virtual ~Service_Query_args() throw() {}

  Queries queries;

  _Service_Query_args__isset __isset;

  void __set_queries(const Queries& val) {
    queries = val;
  }

  bool operator == (const Service_Query_args & rhs) const
  {
    if (!(queries == rhs.queries))
      return false;
    return true;
  }
  bool operator != (const Service_Query_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Query_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_Query_pargs {
 public:


  virtual ~Service_Query_pargs() throw() {}

  const Queries* queries;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Query_result__isset {
  _Service_Query_result__isset() : success(false) {}
  bool success;
} _Service_Query_result__isset;

class Service_Query_result {
 public:

  Service_Query_result() {
  }

  virtual ~Service_Query_result() throw() {}

  ReadResults success;

  _Service_Query_result__isset __isset;

  void __set_success(const ReadResults& val) {
    success = val;
  }

  bool operator == (const Service_Query_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_Query_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_Query_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_Query_presult__isset {
  _Service_Query_presult__isset() : success(false) {}
  bool success;
} _Service_Query_presult__isset;

class Service_Query_presult {
 public:


  virtual ~Service_Query_presult() throw() {}

  ReadResults* success;

  _Service_Query_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_GetStatistics_args__isset {
  _Service_GetStatistics_args__isset() : columnIDs(false) {}
  bool columnIDs;
} _Service_GetStatistics_args__isset;

class Service_GetStatistics_args {
 public:

  Service_GetStatistics_args() {
  }

  virtual ~Service_GetStatistics_args() throw() {}

  std::vector<ColumnID>  columnIDs;

  _Service_GetStatistics_args__isset __isset;

  void __set_columnIDs(const std::vector<ColumnID> & val) {
    columnIDs = val;
  }

  bool operator == (const Service_GetStatistics_args & rhs) const
  {
    if (!(columnIDs == rhs.columnIDs))
      return false;
    return true;
  }
  bool operator != (const Service_GetStatistics_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetStatistics_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_GetStatistics_pargs {
 public:


  virtual ~Service_GetStatistics_pargs() throw() {}

  const std::vector<ColumnID> * columnIDs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetStatistics_result__isset {
  _Service_GetStatistics_result__isset() : success(false) {}
  bool success;
} _Service_GetStatistics_result__isset;

class Service_GetStatistics_result {
 public:

  Service_GetStatistics_result() {
  }

  virtual ~Service_GetStatistics_result() throw() {}

  std::vector<Statistic>  success;

  _Service_GetStatistics_result__isset __isset;

  void __set_success(const std::vector<Statistic> & val) {
    success = val;
  }

  bool operator == (const Service_GetStatistics_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_GetStatistics_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_GetStatistics_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_GetStatistics_presult__isset {
  _Service_GetStatistics_presult__isset() : success(false) {}
  bool success;
} _Service_GetStatistics_presult__isset;

class Service_GetStatistics_presult {
 public:


  virtual ~Service_GetStatistics_presult() throw() {}

  std::vector<Statistic> * success;

  _Service_GetStatistics_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ServiceClient : virtual public ServiceIf {
 public:
  ServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  ServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void GetTopology(TopologyResult& _return);
  void send_GetTopology();
  void recv_GetTopology(TopologyResult& _return);
  Revision PrepareTopology(const TransactionID& transactionID, const Topology& topology);
  void send_PrepareTopology(const TransactionID& transactionID, const Topology& topology);
  Revision recv_PrepareTopology();
  void CommitTopology(const TransactionID& transactionID);
  void send_CommitTopology(const TransactionID& transactionID);
  void recv_CommitTopology();
  void RollbackTopology(const TransactionID& transactionID);
  void send_RollbackTopology(const TransactionID& transactionID);
  void recv_RollbackTopology();
  void GetTopologyReport(TopologyReport& _return);
  void send_GetTopologyReport();
  void recv_GetTopologyReport(TopologyReport& _return);
  void GetReport(HostReport& _return);
  void send_GetReport();
  void recv_GetReport(HostReport& _return);
  Revision Prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  void send_Prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  Revision recv_Prepare();
  void Apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes);
  void send_Apply(const TransactionID& transactionID, const Writes& writes);
  void recv_Apply(TransactionID& _return);
  void Commit(const TransactionID& transactionID);
  void send_Commit(const TransactionID& transactionID);
  void recv_Commit();
  void Rollback(const TransactionID& transactionID);
  void send_Rollback(const TransactionID& transactionID);
  void recv_Rollback();
  void Flush(const TransactionID& transactionID);
  void send_Flush(const TransactionID& transactionID);
  void recv_Flush();
  bool DoesConflict(const Reads& reads, const Revision source, const Revision target);
  void send_DoesConflict(const Reads& reads, const Revision source, const Revision target);
  bool recv_DoesConflict();
  void Update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  void send_Update(const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  void recv_Update(TransactionID& _return);
  void Transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target);
  void send_Transgrade(const Reads& reads, const Revision source, const Revision target);
  void recv_Transgrade(Reads& _return);
  LockID AcquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout);
  void send_AcquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout);
  LockID recv_AcquireLock();
  void KeepLock(const LockID lockID);
  void send_KeepLock(const LockID lockID);
  void recv_KeepLock();
  void EscalateLock(const LockID lockID, const LockTimeout timeout);
  void send_EscalateLock(const LockID lockID, const LockTimeout timeout);
  void recv_EscalateLock();
  void ReleaseLock(const LockID lockID);
  void send_ReleaseLock(const LockID lockID);
  void recv_ReleaseLock();
  void Query(ReadResults& _return, const Queries& queries);
  void send_Query(const Queries& queries);
  void recv_Query(ReadResults& _return);
  void GetStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs);
  void send_GetStatistics(const std::vector<ColumnID> & columnIDs);
  void recv_GetStatistics(std::vector<Statistic> & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<ServiceIf> iface_;
  virtual bool dispatchCall(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ServiceProcessor::*ProcessFunction)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_GetTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_PrepareTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_CommitTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RollbackTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetTopologyReport(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetReport(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Prepare(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Apply(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Commit(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Rollback(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Flush(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_DoesConflict(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Update(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Transgrade(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_AcquireLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_KeepLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_EscalateLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReleaseLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Query(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetStatistics(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ServiceProcessor(boost::shared_ptr<ServiceIf> iface) :
    iface_(iface) {
    processMap_["GetTopology"] = &ServiceProcessor::process_GetTopology;
    processMap_["PrepareTopology"] = &ServiceProcessor::process_PrepareTopology;
    processMap_["CommitTopology"] = &ServiceProcessor::process_CommitTopology;
    processMap_["RollbackTopology"] = &ServiceProcessor::process_RollbackTopology;
    processMap_["GetTopologyReport"] = &ServiceProcessor::process_GetTopologyReport;
    processMap_["GetReport"] = &ServiceProcessor::process_GetReport;
    processMap_["Prepare"] = &ServiceProcessor::process_Prepare;
    processMap_["Apply"] = &ServiceProcessor::process_Apply;
    processMap_["Commit"] = &ServiceProcessor::process_Commit;
    processMap_["Rollback"] = &ServiceProcessor::process_Rollback;
    processMap_["Flush"] = &ServiceProcessor::process_Flush;
    processMap_["DoesConflict"] = &ServiceProcessor::process_DoesConflict;
    processMap_["Update"] = &ServiceProcessor::process_Update;
    processMap_["Transgrade"] = &ServiceProcessor::process_Transgrade;
    processMap_["AcquireLock"] = &ServiceProcessor::process_AcquireLock;
    processMap_["KeepLock"] = &ServiceProcessor::process_KeepLock;
    processMap_["EscalateLock"] = &ServiceProcessor::process_EscalateLock;
    processMap_["ReleaseLock"] = &ServiceProcessor::process_ReleaseLock;
    processMap_["Query"] = &ServiceProcessor::process_Query;
    processMap_["GetStatistics"] = &ServiceProcessor::process_GetStatistics;
  }

  virtual ~ServiceProcessor() {}
};

class ServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ServiceProcessorFactory(const ::boost::shared_ptr< ServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ServiceIfFactory > handlerFactory_;
};

class ServiceMultiface : virtual public ServiceIf {
 public:
  ServiceMultiface(std::vector<boost::shared_ptr<ServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ServiceIf> > ifaces_;
  ServiceMultiface() {}
  void add(boost::shared_ptr<ServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void GetTopology(TopologyResult& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetTopology(_return);
    }
    ifaces_[i]->GetTopology(_return);
    return;
  }

  Revision PrepareTopology(const TransactionID& transactionID, const Topology& topology) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->PrepareTopology(transactionID, topology);
    }
    return ifaces_[i]->PrepareTopology(transactionID, topology);
  }

  void CommitTopology(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->CommitTopology(transactionID);
    }
    ifaces_[i]->CommitTopology(transactionID);
  }

  void RollbackTopology(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RollbackTopology(transactionID);
    }
    ifaces_[i]->RollbackTopology(transactionID);
  }

  void GetTopologyReport(TopologyReport& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetTopologyReport(_return);
    }
    ifaces_[i]->GetTopologyReport(_return);
    return;
  }

  void GetReport(HostReport& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetReport(_return);
    }
    ifaces_[i]->GetReport(_return);
    return;
  }

  Revision Prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Prepare(transactionID, writes, reads);
    }
    return ifaces_[i]->Prepare(transactionID, writes, reads);
  }

  void Apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Apply(_return, transactionID, writes);
    }
    ifaces_[i]->Apply(_return, transactionID, writes);
    return;
  }

  void Commit(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Commit(transactionID);
    }
    ifaces_[i]->Commit(transactionID);
  }

  void Rollback(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Rollback(transactionID);
    }
    ifaces_[i]->Rollback(transactionID);
  }

  void Flush(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Flush(transactionID);
    }
    ifaces_[i]->Flush(transactionID);
  }

  bool DoesConflict(const Reads& reads, const Revision source, const Revision target) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->DoesConflict(reads, source, target);
    }
    return ifaces_[i]->DoesConflict(reads, source, target);
  }

  void Update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Update(_return, transactionID, writes, reads);
    }
    ifaces_[i]->Update(_return, transactionID, writes, reads);
    return;
  }

  void Transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Transgrade(_return, reads, source, target);
    }
    ifaces_[i]->Transgrade(_return, reads, source, target);
    return;
  }

  LockID AcquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->AcquireLock(name, mode, timeout);
    }
    return ifaces_[i]->AcquireLock(name, mode, timeout);
  }

  void KeepLock(const LockID lockID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->KeepLock(lockID);
    }
    ifaces_[i]->KeepLock(lockID);
  }

  void EscalateLock(const LockID lockID, const LockTimeout timeout) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->EscalateLock(lockID, timeout);
    }
    ifaces_[i]->EscalateLock(lockID, timeout);
  }

  void ReleaseLock(const LockID lockID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReleaseLock(lockID);
    }
    ifaces_[i]->ReleaseLock(lockID);
  }

  void Query(ReadResults& _return, const Queries& queries) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Query(_return, queries);
    }
    ifaces_[i]->Query(_return, queries);
    return;
  }

  void GetStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetStatistics(_return, columnIDs);
    }
    ifaces_[i]->GetStatistics(_return, columnIDs);
    return;
  }

};

} // namespace

#endif
