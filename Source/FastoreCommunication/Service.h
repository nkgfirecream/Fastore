/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Service_H
#define Service_H

#include <thrift/TDispatchProcessor.h>
#include "Fastore_types.h"

namespace fastore {

class ServiceIf {
 public:
  virtual ~ServiceIf() {}
  virtual void getTopology(TopologyResult& _return) = 0;
  virtual Revision prepareTopology(const TransactionID& transactionID, const Topology& topology) = 0;
  virtual void commitTopology(const TransactionID& transactionID) = 0;
  virtual void rollbackTopology(const TransactionID& transactionID) = 0;
  virtual void getTopologyReport(TopologyReport& _return) = 0;
  virtual void getReport(HostReport& _return) = 0;
  virtual Revision prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads) = 0;
  virtual void apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes) = 0;
  virtual void commit(const TransactionID& transactionID) = 0;
  virtual void rollback(const TransactionID& transactionID) = 0;
  virtual void flush(const TransactionID& transactionID) = 0;
  virtual bool doesConflict(const Reads& reads, const Revision source, const Revision target) = 0;
  virtual void update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads) = 0;
  virtual void transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target) = 0;
  virtual LockID acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) = 0;
  virtual void keepLock(const LockID lockID) = 0;
  virtual void escalateLock(const LockID lockID, const LockTimeout timeout) = 0;
  virtual void releaseLock(const LockID lockID) = 0;
  virtual void query(ReadResults& _return, const Queries& queries) = 0;
  virtual void getStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs) = 0;
};

class ServiceIfFactory {
 public:
  typedef ServiceIf Handler;

  virtual ~ServiceIfFactory() {}

  virtual ServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ServiceIf* /* handler */) = 0;
};

class ServiceIfSingletonFactory : virtual public ServiceIfFactory {
 public:
  ServiceIfSingletonFactory(const boost::shared_ptr<ServiceIf>& iface) : iface_(iface) {}
  virtual ~ServiceIfSingletonFactory() {}

  virtual ServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<ServiceIf> iface_;
};

class ServiceNull : virtual public ServiceIf {
 public:
  virtual ~ServiceNull() {}
  void getTopology(TopologyResult& /* _return */) {
    return;
  }
  Revision prepareTopology(const TransactionID& /* transactionID */, const Topology& /* topology */) {
    Revision _return = 0;
    return _return;
  }
  void commitTopology(const TransactionID& /* transactionID */) {
    return;
  }
  void rollbackTopology(const TransactionID& /* transactionID */) {
    return;
  }
  void getTopologyReport(TopologyReport& /* _return */) {
    return;
  }
  void getReport(HostReport& /* _return */) {
    return;
  }
  Revision prepare(const TransactionID& /* transactionID */, const Writes& /* writes */, const Reads& /* reads */) {
    Revision _return = 0;
    return _return;
  }
  void apply(TransactionID& /* _return */, const TransactionID& /* transactionID */, const Writes& /* writes */) {
    return;
  }
  void commit(const TransactionID& /* transactionID */) {
    return;
  }
  void rollback(const TransactionID& /* transactionID */) {
    return;
  }
  void flush(const TransactionID& /* transactionID */) {
    return;
  }
  bool doesConflict(const Reads& /* reads */, const Revision /* source */, const Revision /* target */) {
    bool _return = false;
    return _return;
  }
  void update(TransactionID& /* _return */, const TransactionID& /* transactionID */, const Writes& /* writes */, const Reads& /* reads */) {
    return;
  }
  void transgrade(Reads& /* _return */, const Reads& /* reads */, const Revision /* source */, const Revision /* target */) {
    return;
  }
  LockID acquireLock(const LockName& /* name */, const LockMode::type /* mode */, const LockTimeout /* timeout */) {
    LockID _return = 0;
    return _return;
  }
  void keepLock(const LockID /* lockID */) {
    return;
  }
  void escalateLock(const LockID /* lockID */, const LockTimeout /* timeout */) {
    return;
  }
  void releaseLock(const LockID /* lockID */) {
    return;
  }
  void query(ReadResults& /* _return */, const Queries& /* queries */) {
    return;
  }
  void getStatistics(std::vector<Statistic> & /* _return */, const std::vector<ColumnID> & /* columnIDs */) {
    return;
  }
};


class Service_getTopology_args {
 public:

  Service_getTopology_args() {
  }

  virtual ~Service_getTopology_args() throw() {}


  bool operator == (const Service_getTopology_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_getTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getTopology_pargs {
 public:


  virtual ~Service_getTopology_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getTopology_result__isset {
  _Service_getTopology_result__isset() : success(false) {}
  bool success;
} _Service_getTopology_result__isset;

class Service_getTopology_result {
 public:

  Service_getTopology_result() {
  }

  virtual ~Service_getTopology_result() throw() {}

  TopologyResult success;

  _Service_getTopology_result__isset __isset;

  void __set_success(const TopologyResult& val) {
    success = val;
  }

  bool operator == (const Service_getTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getTopology_presult__isset {
  _Service_getTopology_presult__isset() : success(false) {}
  bool success;
} _Service_getTopology_presult__isset;

class Service_getTopology_presult {
 public:


  virtual ~Service_getTopology_presult() throw() {}

  TopologyResult* success;

  _Service_getTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_prepareTopology_args__isset {
  _Service_prepareTopology_args__isset() : transactionID(false), topology(false) {}
  bool transactionID;
  bool topology;
} _Service_prepareTopology_args__isset;

class Service_prepareTopology_args {
 public:

  Service_prepareTopology_args() {
  }

  virtual ~Service_prepareTopology_args() throw() {}

  TransactionID transactionID;
  Topology topology;

  _Service_prepareTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_topology(const Topology& val) {
    topology = val;
  }

  bool operator == (const Service_prepareTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(topology == rhs.topology))
      return false;
    return true;
  }
  bool operator != (const Service_prepareTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_prepareTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_prepareTopology_pargs {
 public:


  virtual ~Service_prepareTopology_pargs() throw() {}

  const TransactionID* transactionID;
  const Topology* topology;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_prepareTopology_result__isset {
  _Service_prepareTopology_result__isset() : success(false) {}
  bool success;
} _Service_prepareTopology_result__isset;

class Service_prepareTopology_result {
 public:

  Service_prepareTopology_result() : success(0) {
  }

  virtual ~Service_prepareTopology_result() throw() {}

  Revision success;

  _Service_prepareTopology_result__isset __isset;

  void __set_success(const Revision val) {
    success = val;
  }

  bool operator == (const Service_prepareTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_prepareTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_prepareTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_prepareTopology_presult__isset {
  _Service_prepareTopology_presult__isset() : success(false) {}
  bool success;
} _Service_prepareTopology_presult__isset;

class Service_prepareTopology_presult {
 public:


  virtual ~Service_prepareTopology_presult() throw() {}

  Revision* success;

  _Service_prepareTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_commitTopology_args__isset {
  _Service_commitTopology_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_commitTopology_args__isset;

class Service_commitTopology_args {
 public:

  Service_commitTopology_args() {
  }

  virtual ~Service_commitTopology_args() throw() {}

  TransactionID transactionID;

  _Service_commitTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_commitTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_commitTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_commitTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commitTopology_pargs {
 public:


  virtual ~Service_commitTopology_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commitTopology_result {
 public:

  Service_commitTopology_result() {
  }

  virtual ~Service_commitTopology_result() throw() {}


  bool operator == (const Service_commitTopology_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_commitTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_commitTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commitTopology_presult {
 public:


  virtual ~Service_commitTopology_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_rollbackTopology_args__isset {
  _Service_rollbackTopology_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_rollbackTopology_args__isset;

class Service_rollbackTopology_args {
 public:

  Service_rollbackTopology_args() {
  }

  virtual ~Service_rollbackTopology_args() throw() {}

  TransactionID transactionID;

  _Service_rollbackTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_rollbackTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_rollbackTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_rollbackTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollbackTopology_pargs {
 public:


  virtual ~Service_rollbackTopology_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollbackTopology_result {
 public:

  Service_rollbackTopology_result() {
  }

  virtual ~Service_rollbackTopology_result() throw() {}


  bool operator == (const Service_rollbackTopology_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_rollbackTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_rollbackTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollbackTopology_presult {
 public:


  virtual ~Service_rollbackTopology_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Service_getTopologyReport_args {
 public:

  Service_getTopologyReport_args() {
  }

  virtual ~Service_getTopologyReport_args() throw() {}


  bool operator == (const Service_getTopologyReport_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_getTopologyReport_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getTopologyReport_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getTopologyReport_pargs {
 public:


  virtual ~Service_getTopologyReport_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getTopologyReport_result__isset {
  _Service_getTopologyReport_result__isset() : success(false) {}
  bool success;
} _Service_getTopologyReport_result__isset;

class Service_getTopologyReport_result {
 public:

  Service_getTopologyReport_result() {
  }

  virtual ~Service_getTopologyReport_result() throw() {}

  TopologyReport success;

  _Service_getTopologyReport_result__isset __isset;

  void __set_success(const TopologyReport& val) {
    success = val;
  }

  bool operator == (const Service_getTopologyReport_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getTopologyReport_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getTopologyReport_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getTopologyReport_presult__isset {
  _Service_getTopologyReport_presult__isset() : success(false) {}
  bool success;
} _Service_getTopologyReport_presult__isset;

class Service_getTopologyReport_presult {
 public:


  virtual ~Service_getTopologyReport_presult() throw() {}

  TopologyReport* success;

  _Service_getTopologyReport_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Service_getReport_args {
 public:

  Service_getReport_args() {
  }

  virtual ~Service_getReport_args() throw() {}


  bool operator == (const Service_getReport_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_getReport_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getReport_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getReport_pargs {
 public:


  virtual ~Service_getReport_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getReport_result__isset {
  _Service_getReport_result__isset() : success(false) {}
  bool success;
} _Service_getReport_result__isset;

class Service_getReport_result {
 public:

  Service_getReport_result() {
  }

  virtual ~Service_getReport_result() throw() {}

  HostReport success;

  _Service_getReport_result__isset __isset;

  void __set_success(const HostReport& val) {
    success = val;
  }

  bool operator == (const Service_getReport_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getReport_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getReport_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getReport_presult__isset {
  _Service_getReport_presult__isset() : success(false) {}
  bool success;
} _Service_getReport_presult__isset;

class Service_getReport_presult {
 public:


  virtual ~Service_getReport_presult() throw() {}

  HostReport* success;

  _Service_getReport_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_prepare_args__isset {
  _Service_prepare_args__isset() : transactionID(false), writes(false), reads(false) {}
  bool transactionID;
  bool writes;
  bool reads;
} _Service_prepare_args__isset;

class Service_prepare_args {
 public:

  Service_prepare_args() {
  }

  virtual ~Service_prepare_args() throw() {}

  TransactionID transactionID;
  Writes writes;
  Reads reads;

  _Service_prepare_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_writes(const Writes& val) {
    writes = val;
  }

  void __set_reads(const Reads& val) {
    reads = val;
  }

  bool operator == (const Service_prepare_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(writes == rhs.writes))
      return false;
    if (!(reads == rhs.reads))
      return false;
    return true;
  }
  bool operator != (const Service_prepare_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_prepare_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_prepare_pargs {
 public:


  virtual ~Service_prepare_pargs() throw() {}

  const TransactionID* transactionID;
  const Writes* writes;
  const Reads* reads;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_prepare_result__isset {
  _Service_prepare_result__isset() : success(false), notLatest(false) {}
  bool success;
  bool notLatest;
} _Service_prepare_result__isset;

class Service_prepare_result {
 public:

  Service_prepare_result() : success(0) {
  }

  virtual ~Service_prepare_result() throw() {}

  Revision success;
  NotLatest notLatest;

  _Service_prepare_result__isset __isset;

  void __set_success(const Revision val) {
    success = val;
  }

  void __set_notLatest(const NotLatest& val) {
    notLatest = val;
  }

  bool operator == (const Service_prepare_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(notLatest == rhs.notLatest))
      return false;
    return true;
  }
  bool operator != (const Service_prepare_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_prepare_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_prepare_presult__isset {
  _Service_prepare_presult__isset() : success(false), notLatest(false) {}
  bool success;
  bool notLatest;
} _Service_prepare_presult__isset;

class Service_prepare_presult {
 public:


  virtual ~Service_prepare_presult() throw() {}

  Revision* success;
  NotLatest notLatest;

  _Service_prepare_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_apply_args__isset {
  _Service_apply_args__isset() : transactionID(false), writes(false) {}
  bool transactionID;
  bool writes;
} _Service_apply_args__isset;

class Service_apply_args {
 public:

  Service_apply_args() {
  }

  virtual ~Service_apply_args() throw() {}

  TransactionID transactionID;
  Writes writes;

  _Service_apply_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_writes(const Writes& val) {
    writes = val;
  }

  bool operator == (const Service_apply_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(writes == rhs.writes))
      return false;
    return true;
  }
  bool operator != (const Service_apply_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_apply_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_apply_pargs {
 public:


  virtual ~Service_apply_pargs() throw() {}

  const TransactionID* transactionID;
  const Writes* writes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_apply_result__isset {
  _Service_apply_result__isset() : success(false) {}
  bool success;
} _Service_apply_result__isset;

class Service_apply_result {
 public:

  Service_apply_result() {
  }

  virtual ~Service_apply_result() throw() {}

  TransactionID success;

  _Service_apply_result__isset __isset;

  void __set_success(const TransactionID& val) {
    success = val;
  }

  bool operator == (const Service_apply_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_apply_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_apply_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_apply_presult__isset {
  _Service_apply_presult__isset() : success(false) {}
  bool success;
} _Service_apply_presult__isset;

class Service_apply_presult {
 public:


  virtual ~Service_apply_presult() throw() {}

  TransactionID* success;

  _Service_apply_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_commit_args__isset {
  _Service_commit_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_commit_args__isset;

class Service_commit_args {
 public:

  Service_commit_args() {
  }

  virtual ~Service_commit_args() throw() {}

  TransactionID transactionID;

  _Service_commit_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_commit_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_commit_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_commit_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commit_pargs {
 public:


  virtual ~Service_commit_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commit_result {
 public:

  Service_commit_result() {
  }

  virtual ~Service_commit_result() throw() {}


  bool operator == (const Service_commit_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_commit_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_commit_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commit_presult {
 public:


  virtual ~Service_commit_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_rollback_args__isset {
  _Service_rollback_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_rollback_args__isset;

class Service_rollback_args {
 public:

  Service_rollback_args() {
  }

  virtual ~Service_rollback_args() throw() {}

  TransactionID transactionID;

  _Service_rollback_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_rollback_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_rollback_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_rollback_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollback_pargs {
 public:


  virtual ~Service_rollback_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollback_result {
 public:

  Service_rollback_result() {
  }

  virtual ~Service_rollback_result() throw() {}


  bool operator == (const Service_rollback_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_rollback_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_rollback_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollback_presult {
 public:


  virtual ~Service_rollback_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_flush_args__isset {
  _Service_flush_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_flush_args__isset;

class Service_flush_args {
 public:

  Service_flush_args() {
  }

  virtual ~Service_flush_args() throw() {}

  TransactionID transactionID;

  _Service_flush_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_flush_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_flush_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_flush_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_flush_pargs {
 public:


  virtual ~Service_flush_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_flush_result {
 public:

  Service_flush_result() {
  }

  virtual ~Service_flush_result() throw() {}


  bool operator == (const Service_flush_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_flush_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_flush_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_flush_presult {
 public:


  virtual ~Service_flush_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_doesConflict_args__isset {
  _Service_doesConflict_args__isset() : reads(false), source(false), target(false) {}
  bool reads;
  bool source;
  bool target;
} _Service_doesConflict_args__isset;

class Service_doesConflict_args {
 public:

  Service_doesConflict_args() : source(0), target(0) {
  }

  virtual ~Service_doesConflict_args() throw() {}

  Reads reads;
  Revision source;
  Revision target;

  _Service_doesConflict_args__isset __isset;

  void __set_reads(const Reads& val) {
    reads = val;
  }

  void __set_source(const Revision val) {
    source = val;
  }

  void __set_target(const Revision val) {
    target = val;
  }

  bool operator == (const Service_doesConflict_args & rhs) const
  {
    if (!(reads == rhs.reads))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(target == rhs.target))
      return false;
    return true;
  }
  bool operator != (const Service_doesConflict_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_doesConflict_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_doesConflict_pargs {
 public:


  virtual ~Service_doesConflict_pargs() throw() {}

  const Reads* reads;
  const Revision* source;
  const Revision* target;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_doesConflict_result__isset {
  _Service_doesConflict_result__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_doesConflict_result__isset;

class Service_doesConflict_result {
 public:

  Service_doesConflict_result() : success(0) {
  }

  virtual ~Service_doesConflict_result() throw() {}

  bool success;
  BeyondHistory beyondHistory;

  _Service_doesConflict_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_beyondHistory(const BeyondHistory& val) {
    beyondHistory = val;
  }

  bool operator == (const Service_doesConflict_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(beyondHistory == rhs.beyondHistory))
      return false;
    return true;
  }
  bool operator != (const Service_doesConflict_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_doesConflict_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_doesConflict_presult__isset {
  _Service_doesConflict_presult__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_doesConflict_presult__isset;

class Service_doesConflict_presult {
 public:


  virtual ~Service_doesConflict_presult() throw() {}

  bool* success;
  BeyondHistory beyondHistory;

  _Service_doesConflict_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_update_args__isset {
  _Service_update_args__isset() : transactionID(false), writes(false), reads(false) {}
  bool transactionID;
  bool writes;
  bool reads;
} _Service_update_args__isset;

class Service_update_args {
 public:

  Service_update_args() {
  }

  virtual ~Service_update_args() throw() {}

  TransactionID transactionID;
  Writes writes;
  Reads reads;

  _Service_update_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_writes(const Writes& val) {
    writes = val;
  }

  void __set_reads(const Reads& val) {
    reads = val;
  }

  bool operator == (const Service_update_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(writes == rhs.writes))
      return false;
    if (!(reads == rhs.reads))
      return false;
    return true;
  }
  bool operator != (const Service_update_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_update_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_update_pargs {
 public:


  virtual ~Service_update_pargs() throw() {}

  const TransactionID* transactionID;
  const Writes* writes;
  const Reads* reads;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_update_result__isset {
  _Service_update_result__isset() : success(false), conflict(false) {}
  bool success;
  bool conflict;
} _Service_update_result__isset;

class Service_update_result {
 public:

  Service_update_result() {
  }

  virtual ~Service_update_result() throw() {}

  TransactionID success;
  Conflict conflict;

  _Service_update_result__isset __isset;

  void __set_success(const TransactionID& val) {
    success = val;
  }

  void __set_conflict(const Conflict& val) {
    conflict = val;
  }

  bool operator == (const Service_update_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(conflict == rhs.conflict))
      return false;
    return true;
  }
  bool operator != (const Service_update_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_update_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_update_presult__isset {
  _Service_update_presult__isset() : success(false), conflict(false) {}
  bool success;
  bool conflict;
} _Service_update_presult__isset;

class Service_update_presult {
 public:


  virtual ~Service_update_presult() throw() {}

  TransactionID* success;
  Conflict conflict;

  _Service_update_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_transgrade_args__isset {
  _Service_transgrade_args__isset() : reads(false), source(false), target(false) {}
  bool reads;
  bool source;
  bool target;
} _Service_transgrade_args__isset;

class Service_transgrade_args {
 public:

  Service_transgrade_args() : source(0), target(0) {
  }

  virtual ~Service_transgrade_args() throw() {}

  Reads reads;
  Revision source;
  Revision target;

  _Service_transgrade_args__isset __isset;

  void __set_reads(const Reads& val) {
    reads = val;
  }

  void __set_source(const Revision val) {
    source = val;
  }

  void __set_target(const Revision val) {
    target = val;
  }

  bool operator == (const Service_transgrade_args & rhs) const
  {
    if (!(reads == rhs.reads))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(target == rhs.target))
      return false;
    return true;
  }
  bool operator != (const Service_transgrade_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_transgrade_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_transgrade_pargs {
 public:


  virtual ~Service_transgrade_pargs() throw() {}

  const Reads* reads;
  const Revision* source;
  const Revision* target;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_transgrade_result__isset {
  _Service_transgrade_result__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_transgrade_result__isset;

class Service_transgrade_result {
 public:

  Service_transgrade_result() {
  }

  virtual ~Service_transgrade_result() throw() {}

  Reads success;
  BeyondHistory beyondHistory;

  _Service_transgrade_result__isset __isset;

  void __set_success(const Reads& val) {
    success = val;
  }

  void __set_beyondHistory(const BeyondHistory& val) {
    beyondHistory = val;
  }

  bool operator == (const Service_transgrade_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(beyondHistory == rhs.beyondHistory))
      return false;
    return true;
  }
  bool operator != (const Service_transgrade_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_transgrade_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_transgrade_presult__isset {
  _Service_transgrade_presult__isset() : success(false), beyondHistory(false) {}
  bool success;
  bool beyondHistory;
} _Service_transgrade_presult__isset;

class Service_transgrade_presult {
 public:


  virtual ~Service_transgrade_presult() throw() {}

  Reads* success;
  BeyondHistory beyondHistory;

  _Service_transgrade_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_acquireLock_args__isset {
  _Service_acquireLock_args__isset() : name(false), mode(false), timeout(true) {}
  bool name;
  bool mode;
  bool timeout;
} _Service_acquireLock_args__isset;

class Service_acquireLock_args {
 public:

  Service_acquireLock_args() : name(), mode((LockMode::type)0), timeout(1000) {
  }

  virtual ~Service_acquireLock_args() throw() {}

  LockName name;
  LockMode::type mode;
  LockTimeout timeout;

  _Service_acquireLock_args__isset __isset;

  void __set_name(const LockName& val) {
    name = val;
  }

  void __set_mode(const LockMode::type val) {
    mode = val;
  }

  void __set_timeout(const LockTimeout val) {
    timeout = val;
  }

  bool operator == (const Service_acquireLock_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(mode == rhs.mode))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_acquireLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_acquireLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_acquireLock_pargs {
 public:


  virtual ~Service_acquireLock_pargs() throw() {}

  const LockName* name;
  const LockMode::type* mode;
  const LockTimeout* timeout;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_acquireLock_result__isset {
  _Service_acquireLock_result__isset() : success(false), timeout(false) {}
  bool success;
  bool timeout;
} _Service_acquireLock_result__isset;

class Service_acquireLock_result {
 public:

  Service_acquireLock_result() : success(0) {
  }

  virtual ~Service_acquireLock_result() throw() {}

  LockID success;
  LockTimedOut timeout;

  _Service_acquireLock_result__isset __isset;

  void __set_success(const LockID val) {
    success = val;
  }

  void __set_timeout(const LockTimedOut& val) {
    timeout = val;
  }

  bool operator == (const Service_acquireLock_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_acquireLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_acquireLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_acquireLock_presult__isset {
  _Service_acquireLock_presult__isset() : success(false), timeout(false) {}
  bool success;
  bool timeout;
} _Service_acquireLock_presult__isset;

class Service_acquireLock_presult {
 public:


  virtual ~Service_acquireLock_presult() throw() {}

  LockID* success;
  LockTimedOut timeout;

  _Service_acquireLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_keepLock_args__isset {
  _Service_keepLock_args__isset() : lockID(false) {}
  bool lockID;
} _Service_keepLock_args__isset;

class Service_keepLock_args {
 public:

  Service_keepLock_args() : lockID(0) {
  }

  virtual ~Service_keepLock_args() throw() {}

  LockID lockID;

  _Service_keepLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  bool operator == (const Service_keepLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    return true;
  }
  bool operator != (const Service_keepLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_keepLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_keepLock_pargs {
 public:


  virtual ~Service_keepLock_pargs() throw() {}

  const LockID* lockID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_keepLock_result__isset {
  _Service_keepLock_result__isset() : expired(false) {}
  bool expired;
} _Service_keepLock_result__isset;

class Service_keepLock_result {
 public:

  Service_keepLock_result() {
  }

  virtual ~Service_keepLock_result() throw() {}

  LockExpired expired;

  _Service_keepLock_result__isset __isset;

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_keepLock_result & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_keepLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_keepLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_keepLock_presult__isset {
  _Service_keepLock_presult__isset() : expired(false) {}
  bool expired;
} _Service_keepLock_presult__isset;

class Service_keepLock_presult {
 public:


  virtual ~Service_keepLock_presult() throw() {}

  LockExpired expired;

  _Service_keepLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_escalateLock_args__isset {
  _Service_escalateLock_args__isset() : lockID(false), timeout(true) {}
  bool lockID;
  bool timeout;
} _Service_escalateLock_args__isset;

class Service_escalateLock_args {
 public:

  Service_escalateLock_args() : lockID(0), timeout(-1) {
  }

  virtual ~Service_escalateLock_args() throw() {}

  LockID lockID;
  LockTimeout timeout;

  _Service_escalateLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  void __set_timeout(const LockTimeout val) {
    timeout = val;
  }

  bool operator == (const Service_escalateLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_escalateLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_escalateLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_escalateLock_pargs {
 public:


  virtual ~Service_escalateLock_pargs() throw() {}

  const LockID* lockID;
  const LockTimeout* timeout;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_escalateLock_result__isset {
  _Service_escalateLock_result__isset() : timeout(false), expired(false) {}
  bool timeout;
  bool expired;
} _Service_escalateLock_result__isset;

class Service_escalateLock_result {
 public:

  Service_escalateLock_result() {
  }

  virtual ~Service_escalateLock_result() throw() {}

  LockTimedOut timeout;
  LockExpired expired;

  _Service_escalateLock_result__isset __isset;

  void __set_timeout(const LockTimedOut& val) {
    timeout = val;
  }

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_escalateLock_result & rhs) const
  {
    if (!(timeout == rhs.timeout))
      return false;
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_escalateLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_escalateLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_escalateLock_presult__isset {
  _Service_escalateLock_presult__isset() : timeout(false), expired(false) {}
  bool timeout;
  bool expired;
} _Service_escalateLock_presult__isset;

class Service_escalateLock_presult {
 public:


  virtual ~Service_escalateLock_presult() throw() {}

  LockTimedOut timeout;
  LockExpired expired;

  _Service_escalateLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_releaseLock_args__isset {
  _Service_releaseLock_args__isset() : lockID(false) {}
  bool lockID;
} _Service_releaseLock_args__isset;

class Service_releaseLock_args {
 public:

  Service_releaseLock_args() : lockID(0) {
  }

  virtual ~Service_releaseLock_args() throw() {}

  LockID lockID;

  _Service_releaseLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  bool operator == (const Service_releaseLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    return true;
  }
  bool operator != (const Service_releaseLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_releaseLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_releaseLock_pargs {
 public:


  virtual ~Service_releaseLock_pargs() throw() {}

  const LockID* lockID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_releaseLock_result__isset {
  _Service_releaseLock_result__isset() : expired(false) {}
  bool expired;
} _Service_releaseLock_result__isset;

class Service_releaseLock_result {
 public:

  Service_releaseLock_result() {
  }

  virtual ~Service_releaseLock_result() throw() {}

  LockExpired expired;

  _Service_releaseLock_result__isset __isset;

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_releaseLock_result & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_releaseLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_releaseLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_releaseLock_presult__isset {
  _Service_releaseLock_presult__isset() : expired(false) {}
  bool expired;
} _Service_releaseLock_presult__isset;

class Service_releaseLock_presult {
 public:


  virtual ~Service_releaseLock_presult() throw() {}

  LockExpired expired;

  _Service_releaseLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_query_args__isset {
  _Service_query_args__isset() : queries(false) {}
  bool queries;
} _Service_query_args__isset;

class Service_query_args {
 public:

  Service_query_args() {
  }

  virtual ~Service_query_args() throw() {}

  Queries queries;

  _Service_query_args__isset __isset;

  void __set_queries(const Queries& val) {
    queries = val;
  }

  bool operator == (const Service_query_args & rhs) const
  {
    if (!(queries == rhs.queries))
      return false;
    return true;
  }
  bool operator != (const Service_query_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_query_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_query_pargs {
 public:


  virtual ~Service_query_pargs() throw() {}

  const Queries* queries;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_query_result__isset {
  _Service_query_result__isset() : success(false) {}
  bool success;
} _Service_query_result__isset;

class Service_query_result {
 public:

  Service_query_result() {
  }

  virtual ~Service_query_result() throw() {}

  ReadResults success;

  _Service_query_result__isset __isset;

  void __set_success(const ReadResults& val) {
    success = val;
  }

  bool operator == (const Service_query_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_query_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_query_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_query_presult__isset {
  _Service_query_presult__isset() : success(false) {}
  bool success;
} _Service_query_presult__isset;

class Service_query_presult {
 public:


  virtual ~Service_query_presult() throw() {}

  ReadResults* success;

  _Service_query_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_getStatistics_args__isset {
  _Service_getStatistics_args__isset() : columnIDs(false) {}
  bool columnIDs;
} _Service_getStatistics_args__isset;

class Service_getStatistics_args {
 public:

  Service_getStatistics_args() {
  }

  virtual ~Service_getStatistics_args() throw() {}

  std::vector<ColumnID>  columnIDs;

  _Service_getStatistics_args__isset __isset;

  void __set_columnIDs(const std::vector<ColumnID> & val) {
    columnIDs = val;
  }

  bool operator == (const Service_getStatistics_args & rhs) const
  {
    if (!(columnIDs == rhs.columnIDs))
      return false;
    return true;
  }
  bool operator != (const Service_getStatistics_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getStatistics_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getStatistics_pargs {
 public:


  virtual ~Service_getStatistics_pargs() throw() {}

  const std::vector<ColumnID> * columnIDs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getStatistics_result__isset {
  _Service_getStatistics_result__isset() : success(false) {}
  bool success;
} _Service_getStatistics_result__isset;

class Service_getStatistics_result {
 public:

  Service_getStatistics_result() {
  }

  virtual ~Service_getStatistics_result() throw() {}

  std::vector<Statistic>  success;

  _Service_getStatistics_result__isset __isset;

  void __set_success(const std::vector<Statistic> & val) {
    success = val;
  }

  bool operator == (const Service_getStatistics_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getStatistics_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getStatistics_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getStatistics_presult__isset {
  _Service_getStatistics_presult__isset() : success(false) {}
  bool success;
} _Service_getStatistics_presult__isset;

class Service_getStatistics_presult {
 public:


  virtual ~Service_getStatistics_presult() throw() {}

  std::vector<Statistic> * success;

  _Service_getStatistics_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ServiceClient : virtual public ServiceIf {
 public:
  ServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  ServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getTopology(TopologyResult& _return);
  void send_getTopology();
  void recv_getTopology(TopologyResult& _return);
  Revision prepareTopology(const TransactionID& transactionID, const Topology& topology);
  void send_prepareTopology(const TransactionID& transactionID, const Topology& topology);
  Revision recv_prepareTopology();
  void commitTopology(const TransactionID& transactionID);
  void send_commitTopology(const TransactionID& transactionID);
  void recv_commitTopology();
  void rollbackTopology(const TransactionID& transactionID);
  void send_rollbackTopology(const TransactionID& transactionID);
  void recv_rollbackTopology();
  void getTopologyReport(TopologyReport& _return);
  void send_getTopologyReport();
  void recv_getTopologyReport(TopologyReport& _return);
  void getReport(HostReport& _return);
  void send_getReport();
  void recv_getReport(HostReport& _return);
  Revision prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  void send_prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  Revision recv_prepare();
  void apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes);
  void send_apply(const TransactionID& transactionID, const Writes& writes);
  void recv_apply(TransactionID& _return);
  void commit(const TransactionID& transactionID);
  void send_commit(const TransactionID& transactionID);
  void recv_commit();
  void rollback(const TransactionID& transactionID);
  void send_rollback(const TransactionID& transactionID);
  void recv_rollback();
  void flush(const TransactionID& transactionID);
  void send_flush(const TransactionID& transactionID);
  void recv_flush();
  bool doesConflict(const Reads& reads, const Revision source, const Revision target);
  void send_doesConflict(const Reads& reads, const Revision source, const Revision target);
  bool recv_doesConflict();
  void update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  void send_update(const TransactionID& transactionID, const Writes& writes, const Reads& reads);
  void recv_update(TransactionID& _return);
  void transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target);
  void send_transgrade(const Reads& reads, const Revision source, const Revision target);
  void recv_transgrade(Reads& _return);
  LockID acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout);
  void send_acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout);
  LockID recv_acquireLock();
  void keepLock(const LockID lockID);
  void send_keepLock(const LockID lockID);
  void recv_keepLock();
  void escalateLock(const LockID lockID, const LockTimeout timeout);
  void send_escalateLock(const LockID lockID, const LockTimeout timeout);
  void recv_escalateLock();
  void releaseLock(const LockID lockID);
  void send_releaseLock(const LockID lockID);
  void recv_releaseLock();
  void query(ReadResults& _return, const Queries& queries);
  void send_query(const Queries& queries);
  void recv_query(ReadResults& _return);
  void getStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs);
  void send_getStatistics(const std::vector<ColumnID> & columnIDs);
  void recv_getStatistics(std::vector<Statistic> & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<ServiceIf> iface_;
  virtual bool dispatchCall(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ServiceProcessor::*ProcessFunction)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_prepareTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_commitTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rollbackTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTopologyReport(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getReport(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_prepare(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_apply(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_commit(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rollback(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_flush(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_doesConflict(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_update(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_transgrade(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_acquireLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_keepLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_escalateLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_releaseLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_query(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getStatistics(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ServiceProcessor(boost::shared_ptr<ServiceIf> iface) :
    iface_(iface) {
    processMap_["getTopology"] = &ServiceProcessor::process_getTopology;
    processMap_["prepareTopology"] = &ServiceProcessor::process_prepareTopology;
    processMap_["commitTopology"] = &ServiceProcessor::process_commitTopology;
    processMap_["rollbackTopology"] = &ServiceProcessor::process_rollbackTopology;
    processMap_["getTopologyReport"] = &ServiceProcessor::process_getTopologyReport;
    processMap_["getReport"] = &ServiceProcessor::process_getReport;
    processMap_["prepare"] = &ServiceProcessor::process_prepare;
    processMap_["apply"] = &ServiceProcessor::process_apply;
    processMap_["commit"] = &ServiceProcessor::process_commit;
    processMap_["rollback"] = &ServiceProcessor::process_rollback;
    processMap_["flush"] = &ServiceProcessor::process_flush;
    processMap_["doesConflict"] = &ServiceProcessor::process_doesConflict;
    processMap_["update"] = &ServiceProcessor::process_update;
    processMap_["transgrade"] = &ServiceProcessor::process_transgrade;
    processMap_["acquireLock"] = &ServiceProcessor::process_acquireLock;
    processMap_["keepLock"] = &ServiceProcessor::process_keepLock;
    processMap_["escalateLock"] = &ServiceProcessor::process_escalateLock;
    processMap_["releaseLock"] = &ServiceProcessor::process_releaseLock;
    processMap_["query"] = &ServiceProcessor::process_query;
    processMap_["getStatistics"] = &ServiceProcessor::process_getStatistics;
  }

  virtual ~ServiceProcessor() {}
};

class ServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ServiceProcessorFactory(const ::boost::shared_ptr< ServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ServiceIfFactory > handlerFactory_;
};

class ServiceMultiface : virtual public ServiceIf {
 public:
  ServiceMultiface(std::vector<boost::shared_ptr<ServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ServiceIf> > ifaces_;
  ServiceMultiface() {}
  void add(boost::shared_ptr<ServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void getTopology(TopologyResult& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopology(_return);
    }
    ifaces_[i]->getTopology(_return);
    return;
  }

  Revision prepareTopology(const TransactionID& transactionID, const Topology& topology) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->prepareTopology(transactionID, topology);
    }
    return ifaces_[i]->prepareTopology(transactionID, topology);
  }

  void commitTopology(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->commitTopology(transactionID);
    }
    ifaces_[i]->commitTopology(transactionID);
  }

  void rollbackTopology(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rollbackTopology(transactionID);
    }
    ifaces_[i]->rollbackTopology(transactionID);
  }

  void getTopologyReport(TopologyReport& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopologyReport(_return);
    }
    ifaces_[i]->getTopologyReport(_return);
    return;
  }

  void getReport(HostReport& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getReport(_return);
    }
    ifaces_[i]->getReport(_return);
    return;
  }

  Revision prepare(const TransactionID& transactionID, const Writes& writes, const Reads& reads) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->prepare(transactionID, writes, reads);
    }
    return ifaces_[i]->prepare(transactionID, writes, reads);
  }

  void apply(TransactionID& _return, const TransactionID& transactionID, const Writes& writes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->apply(_return, transactionID, writes);
    }
    ifaces_[i]->apply(_return, transactionID, writes);
    return;
  }

  void commit(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->commit(transactionID);
    }
    ifaces_[i]->commit(transactionID);
  }

  void rollback(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rollback(transactionID);
    }
    ifaces_[i]->rollback(transactionID);
  }

  void flush(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->flush(transactionID);
    }
    ifaces_[i]->flush(transactionID);
  }

  bool doesConflict(const Reads& reads, const Revision source, const Revision target) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->doesConflict(reads, source, target);
    }
    return ifaces_[i]->doesConflict(reads, source, target);
  }

  void update(TransactionID& _return, const TransactionID& transactionID, const Writes& writes, const Reads& reads) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->update(_return, transactionID, writes, reads);
    }
    ifaces_[i]->update(_return, transactionID, writes, reads);
    return;
  }

  void transgrade(Reads& _return, const Reads& reads, const Revision source, const Revision target) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->transgrade(_return, reads, source, target);
    }
    ifaces_[i]->transgrade(_return, reads, source, target);
    return;
  }

  LockID acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->acquireLock(name, mode, timeout);
    }
    return ifaces_[i]->acquireLock(name, mode, timeout);
  }

  void keepLock(const LockID lockID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->keepLock(lockID);
    }
    ifaces_[i]->keepLock(lockID);
  }

  void escalateLock(const LockID lockID, const LockTimeout timeout) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->escalateLock(lockID, timeout);
    }
    ifaces_[i]->escalateLock(lockID, timeout);
  }

  void releaseLock(const LockID lockID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->releaseLock(lockID);
    }
    ifaces_[i]->releaseLock(lockID);
  }

  void query(ReadResults& _return, const Queries& queries) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->query(_return, queries);
    }
    ifaces_[i]->query(_return, queries);
    return;
  }

  void getStatistics(std::vector<Statistic> & _return, const std::vector<ColumnID> & columnIDs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getStatistics(_return, columnIDs);
    }
    ifaces_[i]->getStatistics(_return, columnIDs);
    return;
  }

};

} // namespace

#endif
