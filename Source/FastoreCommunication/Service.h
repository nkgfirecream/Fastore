/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Service_H
#define Service_H

#include <thrift/TDispatchProcessor.h>
#include "Fastore_types.h"

namespace fastore {

class ServiceIf {
 public:
  virtual ~ServiceIf() {}
  virtual void getTopology(TopologyResult& _return) = 0;
  virtual Revision prepareTopology(const TransactionID& transactionID, const Topology& topology) = 0;
  virtual void commitTopology(const TransactionID& transactionID) = 0;
  virtual void rollbackTopology(const TransactionID& transactionID) = 0;
  virtual void getHiveState(HiveState& _return) = 0;
  virtual void getState(ServiceState& _return) = 0;
  virtual LockID acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) = 0;
  virtual void keepLock(const LockID lockID) = 0;
  virtual void escalateLock(const LockID lockID, const LockTimeout timeout) = 0;
  virtual void releaseLock(const LockID lockID) = 0;
};

class ServiceIfFactory {
 public:
  typedef ServiceIf Handler;

  virtual ~ServiceIfFactory() {}

  virtual ServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ServiceIf* /* handler */) = 0;
};

class ServiceIfSingletonFactory : virtual public ServiceIfFactory {
 public:
  ServiceIfSingletonFactory(const boost::shared_ptr<ServiceIf>& iface) : iface_(iface) {}
  virtual ~ServiceIfSingletonFactory() {}

  virtual ServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<ServiceIf> iface_;
};

class ServiceNull : virtual public ServiceIf {
 public:
  virtual ~ServiceNull() {}
  void getTopology(TopologyResult& /* _return */) {
    return;
  }
  Revision prepareTopology(const TransactionID& /* transactionID */, const Topology& /* topology */) {
    Revision _return = 0;
    return _return;
  }
  void commitTopology(const TransactionID& /* transactionID */) {
    return;
  }
  void rollbackTopology(const TransactionID& /* transactionID */) {
    return;
  }
  void getHiveState(HiveState& /* _return */) {
    return;
  }
  void getState(ServiceState& /* _return */) {
    return;
  }
  LockID acquireLock(const LockName& /* name */, const LockMode::type /* mode */, const LockTimeout /* timeout */) {
    LockID _return = 0;
    return _return;
  }
  void keepLock(const LockID /* lockID */) {
    return;
  }
  void escalateLock(const LockID /* lockID */, const LockTimeout /* timeout */) {
    return;
  }
  void releaseLock(const LockID /* lockID */) {
    return;
  }
};


class Service_getTopology_args {
 public:

  Service_getTopology_args() {
  }

  virtual ~Service_getTopology_args() throw() {}


  bool operator == (const Service_getTopology_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_getTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getTopology_pargs {
 public:


  virtual ~Service_getTopology_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getTopology_result__isset {
  _Service_getTopology_result__isset() : success(false) {}
  bool success;
} _Service_getTopology_result__isset;

class Service_getTopology_result {
 public:

  Service_getTopology_result() {
  }

  virtual ~Service_getTopology_result() throw() {}

  TopologyResult success;

  _Service_getTopology_result__isset __isset;

  void __set_success(const TopologyResult& val) {
    success = val;
  }

  bool operator == (const Service_getTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getTopology_presult__isset {
  _Service_getTopology_presult__isset() : success(false) {}
  bool success;
} _Service_getTopology_presult__isset;

class Service_getTopology_presult {
 public:


  virtual ~Service_getTopology_presult() throw() {}

  TopologyResult* success;

  _Service_getTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_prepareTopology_args__isset {
  _Service_prepareTopology_args__isset() : transactionID(false), topology(false) {}
  bool transactionID;
  bool topology;
} _Service_prepareTopology_args__isset;

class Service_prepareTopology_args {
 public:

  Service_prepareTopology_args() {
  }

  virtual ~Service_prepareTopology_args() throw() {}

  TransactionID transactionID;
  Topology topology;

  _Service_prepareTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  void __set_topology(const Topology& val) {
    topology = val;
  }

  bool operator == (const Service_prepareTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    if (!(topology == rhs.topology))
      return false;
    return true;
  }
  bool operator != (const Service_prepareTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_prepareTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_prepareTopology_pargs {
 public:


  virtual ~Service_prepareTopology_pargs() throw() {}

  const TransactionID* transactionID;
  const Topology* topology;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_prepareTopology_result__isset {
  _Service_prepareTopology_result__isset() : success(false) {}
  bool success;
} _Service_prepareTopology_result__isset;

class Service_prepareTopology_result {
 public:

  Service_prepareTopology_result() : success(0) {
  }

  virtual ~Service_prepareTopology_result() throw() {}

  Revision success;

  _Service_prepareTopology_result__isset __isset;

  void __set_success(const Revision val) {
    success = val;
  }

  bool operator == (const Service_prepareTopology_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_prepareTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_prepareTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_prepareTopology_presult__isset {
  _Service_prepareTopology_presult__isset() : success(false) {}
  bool success;
} _Service_prepareTopology_presult__isset;

class Service_prepareTopology_presult {
 public:


  virtual ~Service_prepareTopology_presult() throw() {}

  Revision* success;

  _Service_prepareTopology_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_commitTopology_args__isset {
  _Service_commitTopology_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_commitTopology_args__isset;

class Service_commitTopology_args {
 public:

  Service_commitTopology_args() {
  }

  virtual ~Service_commitTopology_args() throw() {}

  TransactionID transactionID;

  _Service_commitTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_commitTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_commitTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_commitTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commitTopology_pargs {
 public:


  virtual ~Service_commitTopology_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commitTopology_result {
 public:

  Service_commitTopology_result() {
  }

  virtual ~Service_commitTopology_result() throw() {}


  bool operator == (const Service_commitTopology_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_commitTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_commitTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_commitTopology_presult {
 public:


  virtual ~Service_commitTopology_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_rollbackTopology_args__isset {
  _Service_rollbackTopology_args__isset() : transactionID(false) {}
  bool transactionID;
} _Service_rollbackTopology_args__isset;

class Service_rollbackTopology_args {
 public:

  Service_rollbackTopology_args() {
  }

  virtual ~Service_rollbackTopology_args() throw() {}

  TransactionID transactionID;

  _Service_rollbackTopology_args__isset __isset;

  void __set_transactionID(const TransactionID& val) {
    transactionID = val;
  }

  bool operator == (const Service_rollbackTopology_args & rhs) const
  {
    if (!(transactionID == rhs.transactionID))
      return false;
    return true;
  }
  bool operator != (const Service_rollbackTopology_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_rollbackTopology_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollbackTopology_pargs {
 public:


  virtual ~Service_rollbackTopology_pargs() throw() {}

  const TransactionID* transactionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollbackTopology_result {
 public:

  Service_rollbackTopology_result() {
  }

  virtual ~Service_rollbackTopology_result() throw() {}


  bool operator == (const Service_rollbackTopology_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_rollbackTopology_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_rollbackTopology_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_rollbackTopology_presult {
 public:


  virtual ~Service_rollbackTopology_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Service_getHiveState_args {
 public:

  Service_getHiveState_args() {
  }

  virtual ~Service_getHiveState_args() throw() {}


  bool operator == (const Service_getHiveState_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_getHiveState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getHiveState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getHiveState_pargs {
 public:


  virtual ~Service_getHiveState_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getHiveState_result__isset {
  _Service_getHiveState_result__isset() : success(false) {}
  bool success;
} _Service_getHiveState_result__isset;

class Service_getHiveState_result {
 public:

  Service_getHiveState_result() {
  }

  virtual ~Service_getHiveState_result() throw() {}

  HiveState success;

  _Service_getHiveState_result__isset __isset;

  void __set_success(const HiveState& val) {
    success = val;
  }

  bool operator == (const Service_getHiveState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getHiveState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getHiveState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getHiveState_presult__isset {
  _Service_getHiveState_presult__isset() : success(false) {}
  bool success;
} _Service_getHiveState_presult__isset;

class Service_getHiveState_presult {
 public:


  virtual ~Service_getHiveState_presult() throw() {}

  HiveState* success;

  _Service_getHiveState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Service_getState_args {
 public:

  Service_getState_args() {
  }

  virtual ~Service_getState_args() throw() {}


  bool operator == (const Service_getState_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Service_getState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_getState_pargs {
 public:


  virtual ~Service_getState_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getState_result__isset {
  _Service_getState_result__isset() : success(false) {}
  bool success;
} _Service_getState_result__isset;

class Service_getState_result {
 public:

  Service_getState_result() {
  }

  virtual ~Service_getState_result() throw() {}

  ServiceState success;

  _Service_getState_result__isset __isset;

  void __set_success(const ServiceState& val) {
    success = val;
  }

  bool operator == (const Service_getState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Service_getState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_getState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_getState_presult__isset {
  _Service_getState_presult__isset() : success(false) {}
  bool success;
} _Service_getState_presult__isset;

class Service_getState_presult {
 public:


  virtual ~Service_getState_presult() throw() {}

  ServiceState* success;

  _Service_getState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_acquireLock_args__isset {
  _Service_acquireLock_args__isset() : name(false), mode(false), timeout(true) {}
  bool name;
  bool mode;
  bool timeout;
} _Service_acquireLock_args__isset;

class Service_acquireLock_args {
 public:

  Service_acquireLock_args() : name(), mode((LockMode::type)0), timeout(1000) {
  }

  virtual ~Service_acquireLock_args() throw() {}

  LockName name;
  LockMode::type mode;
  LockTimeout timeout;

  _Service_acquireLock_args__isset __isset;

  void __set_name(const LockName& val) {
    name = val;
  }

  void __set_mode(const LockMode::type val) {
    mode = val;
  }

  void __set_timeout(const LockTimeout val) {
    timeout = val;
  }

  bool operator == (const Service_acquireLock_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(mode == rhs.mode))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_acquireLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_acquireLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_acquireLock_pargs {
 public:


  virtual ~Service_acquireLock_pargs() throw() {}

  const LockName* name;
  const LockMode::type* mode;
  const LockTimeout* timeout;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_acquireLock_result__isset {
  _Service_acquireLock_result__isset() : success(false), timeout(false) {}
  bool success;
  bool timeout;
} _Service_acquireLock_result__isset;

class Service_acquireLock_result {
 public:

  Service_acquireLock_result() : success(0) {
  }

  virtual ~Service_acquireLock_result() throw() {}

  LockID success;
  LockTimedOut timeout;

  _Service_acquireLock_result__isset __isset;

  void __set_success(const LockID val) {
    success = val;
  }

  void __set_timeout(const LockTimedOut& val) {
    timeout = val;
  }

  bool operator == (const Service_acquireLock_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_acquireLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_acquireLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_acquireLock_presult__isset {
  _Service_acquireLock_presult__isset() : success(false), timeout(false) {}
  bool success;
  bool timeout;
} _Service_acquireLock_presult__isset;

class Service_acquireLock_presult {
 public:


  virtual ~Service_acquireLock_presult() throw() {}

  LockID* success;
  LockTimedOut timeout;

  _Service_acquireLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_keepLock_args__isset {
  _Service_keepLock_args__isset() : lockID(false) {}
  bool lockID;
} _Service_keepLock_args__isset;

class Service_keepLock_args {
 public:

  Service_keepLock_args() : lockID(0) {
  }

  virtual ~Service_keepLock_args() throw() {}

  LockID lockID;

  _Service_keepLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  bool operator == (const Service_keepLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    return true;
  }
  bool operator != (const Service_keepLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_keepLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_keepLock_pargs {
 public:


  virtual ~Service_keepLock_pargs() throw() {}

  const LockID* lockID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_keepLock_result__isset {
  _Service_keepLock_result__isset() : expired(false) {}
  bool expired;
} _Service_keepLock_result__isset;

class Service_keepLock_result {
 public:

  Service_keepLock_result() {
  }

  virtual ~Service_keepLock_result() throw() {}

  LockExpired expired;

  _Service_keepLock_result__isset __isset;

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_keepLock_result & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_keepLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_keepLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_keepLock_presult__isset {
  _Service_keepLock_presult__isset() : expired(false) {}
  bool expired;
} _Service_keepLock_presult__isset;

class Service_keepLock_presult {
 public:


  virtual ~Service_keepLock_presult() throw() {}

  LockExpired expired;

  _Service_keepLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_escalateLock_args__isset {
  _Service_escalateLock_args__isset() : lockID(false), timeout(true) {}
  bool lockID;
  bool timeout;
} _Service_escalateLock_args__isset;

class Service_escalateLock_args {
 public:

  Service_escalateLock_args() : lockID(0), timeout(-1) {
  }

  virtual ~Service_escalateLock_args() throw() {}

  LockID lockID;
  LockTimeout timeout;

  _Service_escalateLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  void __set_timeout(const LockTimeout val) {
    timeout = val;
  }

  bool operator == (const Service_escalateLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const Service_escalateLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_escalateLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_escalateLock_pargs {
 public:


  virtual ~Service_escalateLock_pargs() throw() {}

  const LockID* lockID;
  const LockTimeout* timeout;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_escalateLock_result__isset {
  _Service_escalateLock_result__isset() : timeout(false), expired(false) {}
  bool timeout;
  bool expired;
} _Service_escalateLock_result__isset;

class Service_escalateLock_result {
 public:

  Service_escalateLock_result() {
  }

  virtual ~Service_escalateLock_result() throw() {}

  LockTimedOut timeout;
  LockExpired expired;

  _Service_escalateLock_result__isset __isset;

  void __set_timeout(const LockTimedOut& val) {
    timeout = val;
  }

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_escalateLock_result & rhs) const
  {
    if (!(timeout == rhs.timeout))
      return false;
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_escalateLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_escalateLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_escalateLock_presult__isset {
  _Service_escalateLock_presult__isset() : timeout(false), expired(false) {}
  bool timeout;
  bool expired;
} _Service_escalateLock_presult__isset;

class Service_escalateLock_presult {
 public:


  virtual ~Service_escalateLock_presult() throw() {}

  LockTimedOut timeout;
  LockExpired expired;

  _Service_escalateLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Service_releaseLock_args__isset {
  _Service_releaseLock_args__isset() : lockID(false) {}
  bool lockID;
} _Service_releaseLock_args__isset;

class Service_releaseLock_args {
 public:

  Service_releaseLock_args() : lockID(0) {
  }

  virtual ~Service_releaseLock_args() throw() {}

  LockID lockID;

  _Service_releaseLock_args__isset __isset;

  void __set_lockID(const LockID val) {
    lockID = val;
  }

  bool operator == (const Service_releaseLock_args & rhs) const
  {
    if (!(lockID == rhs.lockID))
      return false;
    return true;
  }
  bool operator != (const Service_releaseLock_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_releaseLock_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Service_releaseLock_pargs {
 public:


  virtual ~Service_releaseLock_pargs() throw() {}

  const LockID* lockID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_releaseLock_result__isset {
  _Service_releaseLock_result__isset() : expired(false) {}
  bool expired;
} _Service_releaseLock_result__isset;

class Service_releaseLock_result {
 public:

  Service_releaseLock_result() {
  }

  virtual ~Service_releaseLock_result() throw() {}

  LockExpired expired;

  _Service_releaseLock_result__isset __isset;

  void __set_expired(const LockExpired& val) {
    expired = val;
  }

  bool operator == (const Service_releaseLock_result & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    return true;
  }
  bool operator != (const Service_releaseLock_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Service_releaseLock_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Service_releaseLock_presult__isset {
  _Service_releaseLock_presult__isset() : expired(false) {}
  bool expired;
} _Service_releaseLock_presult__isset;

class Service_releaseLock_presult {
 public:


  virtual ~Service_releaseLock_presult() throw() {}

  LockExpired expired;

  _Service_releaseLock_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ServiceClient : virtual public ServiceIf {
 public:
  ServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  ServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getTopology(TopologyResult& _return);
  void send_getTopology();
  void recv_getTopology(TopologyResult& _return);
  Revision prepareTopology(const TransactionID& transactionID, const Topology& topology);
  void send_prepareTopology(const TransactionID& transactionID, const Topology& topology);
  Revision recv_prepareTopology();
  void commitTopology(const TransactionID& transactionID);
  void send_commitTopology(const TransactionID& transactionID);
  void recv_commitTopology();
  void rollbackTopology(const TransactionID& transactionID);
  void send_rollbackTopology(const TransactionID& transactionID);
  void recv_rollbackTopology();
  void getHiveState(HiveState& _return);
  void send_getHiveState();
  void recv_getHiveState(HiveState& _return);
  void getState(ServiceState& _return);
  void send_getState();
  void recv_getState(ServiceState& _return);
  LockID acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout);
  void send_acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout);
  LockID recv_acquireLock();
  void keepLock(const LockID lockID);
  void send_keepLock(const LockID lockID);
  void recv_keepLock();
  void escalateLock(const LockID lockID, const LockTimeout timeout);
  void send_escalateLock(const LockID lockID, const LockTimeout timeout);
  void recv_escalateLock();
  void releaseLock(const LockID lockID);
  void send_releaseLock(const LockID lockID);
  void recv_releaseLock();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<ServiceIf> iface_;
  virtual bool dispatchCall(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ServiceProcessor::*ProcessFunction)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_prepareTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_commitTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_rollbackTopology(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getHiveState(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getState(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_acquireLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_keepLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_escalateLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_releaseLock(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ServiceProcessor(boost::shared_ptr<ServiceIf> iface) :
    iface_(iface) {
    processMap_["getTopology"] = &ServiceProcessor::process_getTopology;
    processMap_["prepareTopology"] = &ServiceProcessor::process_prepareTopology;
    processMap_["commitTopology"] = &ServiceProcessor::process_commitTopology;
    processMap_["rollbackTopology"] = &ServiceProcessor::process_rollbackTopology;
    processMap_["getHiveState"] = &ServiceProcessor::process_getHiveState;
    processMap_["getState"] = &ServiceProcessor::process_getState;
    processMap_["acquireLock"] = &ServiceProcessor::process_acquireLock;
    processMap_["keepLock"] = &ServiceProcessor::process_keepLock;
    processMap_["escalateLock"] = &ServiceProcessor::process_escalateLock;
    processMap_["releaseLock"] = &ServiceProcessor::process_releaseLock;
  }

  virtual ~ServiceProcessor() {}
};

class ServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ServiceProcessorFactory(const ::boost::shared_ptr< ServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< ServiceIfFactory > handlerFactory_;
};

class ServiceMultiface : virtual public ServiceIf {
 public:
  ServiceMultiface(std::vector<boost::shared_ptr<ServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<ServiceIf> > ifaces_;
  ServiceMultiface() {}
  void add(boost::shared_ptr<ServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void getTopology(TopologyResult& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTopology(_return);
    }
    ifaces_[i]->getTopology(_return);
    return;
  }

  Revision prepareTopology(const TransactionID& transactionID, const Topology& topology) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->prepareTopology(transactionID, topology);
    }
    return ifaces_[i]->prepareTopology(transactionID, topology);
  }

  void commitTopology(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->commitTopology(transactionID);
    }
    ifaces_[i]->commitTopology(transactionID);
  }

  void rollbackTopology(const TransactionID& transactionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->rollbackTopology(transactionID);
    }
    ifaces_[i]->rollbackTopology(transactionID);
  }

  void getHiveState(HiveState& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getHiveState(_return);
    }
    ifaces_[i]->getHiveState(_return);
    return;
  }

  void getState(ServiceState& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getState(_return);
    }
    ifaces_[i]->getState(_return);
    return;
  }

  LockID acquireLock(const LockName& name, const LockMode::type mode, const LockTimeout timeout) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->acquireLock(name, mode, timeout);
    }
    return ifaces_[i]->acquireLock(name, mode, timeout);
  }

  void keepLock(const LockID lockID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->keepLock(lockID);
    }
    ifaces_[i]->keepLock(lockID);
  }

  void escalateLock(const LockID lockID, const LockTimeout timeout) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->escalateLock(lockID, timeout);
    }
    ifaces_[i]->escalateLock(lockID, timeout);
  }

  void releaseLock(const LockID lockID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->releaseLock(lockID);
    }
    ifaces_[i]->releaseLock(lockID);
  }

};

} // namespace

#endif
