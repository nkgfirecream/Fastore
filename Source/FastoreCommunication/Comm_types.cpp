/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Comm_types.h"

#include <algorithm>

namespace fastore { namespace communication {

int _kRepositoryStatusValues[] = {
  RepositoryStatus::Loading,
  RepositoryStatus::Unloading,
  RepositoryStatus::Online,
  RepositoryStatus::Checkpointing,
  RepositoryStatus::Offline
};
const char* _kRepositoryStatusNames[] = {
  "Loading",
  "Unloading",
  "Online",
  "Checkpointing",
  "Offline"
};
const std::map<int, const char*> _RepositoryStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kRepositoryStatusValues, _kRepositoryStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kServiceStatusValues[] = {
  ServiceStatus::Offline,
  ServiceStatus::Online,
  ServiceStatus::Unreachable
};
const char* _kServiceStatusNames[] = {
  "Offline",
  "Online",
  "Unreachable"
};
const std::map<int, const char*> _ServiceStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kServiceStatusValues, _kServiceStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockModeValues[] = {
  LockMode::Read,
  LockMode::Write
};
const char* _kLockModeNames[] = {
  "Read",
  "Write"
};
const std::map<int, const char*> _LockMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLockModeValues, _kLockModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* NetworkAddress::ascii_fingerprint = "18B162B1D15D8D46509D3911A9F1C2AA";
const uint8_t NetworkAddress::binary_fingerprint[16] = {0x18,0xB1,0x62,0xB1,0xD1,0x5D,0x8D,0x46,0x50,0x9D,0x39,0x11,0xA9,0xF1,0xC2,0xAA};

uint32_t NetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NetworkAddress");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkAddress &a, NetworkAddress &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

const char* WorkerState::ascii_fingerprint = "D576A5D4D687D9BDB02F6FC8D2506D9E";
const uint8_t WorkerState::binary_fingerprint[16] = {0xD5,0x76,0xA5,0xD4,0xD6,0x87,0xD9,0xBD,0xB0,0x2F,0x6F,0xC8,0xD2,0x50,0x6D,0x9E};

uint32_t WorkerState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_repositoryStatus = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->repositoryStatus.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              ColumnID _key5;
              xfer += iprot->readI32(_key5);
              RepositoryStatus::type& _val6 = this->repositoryStatus[_key5];
              int32_t ecast7;
              xfer += iprot->readI32(ecast7);
              _val6 = (RepositoryStatus::type)ecast7;
            }
            iprot->readMapEnd();
          }
          isset_repositoryStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_repositoryStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkerState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WorkerState");

  xfer += oprot->writeFieldBegin("repositoryStatus", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->repositoryStatus.size()));
    std::map<ColumnID, RepositoryStatus::type> ::const_iterator _iter8;
    for (_iter8 = this->repositoryStatus.begin(); _iter8 != this->repositoryStatus.end(); ++_iter8)
    {
      xfer += oprot->writeI32(_iter8->first);
      xfer += oprot->writeI32((int32_t)_iter8->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkerState &a, WorkerState &b) {
  using ::std::swap;
  swap(a.repositoryStatus, b.repositoryStatus);
  swap(a.port, b.port);
}

const char* ServiceState::ascii_fingerprint = "8B2EF7533FE7CD5FF58CED94F3CDCE73";
const uint8_t ServiceState::binary_fingerprint[16] = {0x8B,0x2E,0xF7,0x53,0x3F,0xE7,0xCD,0x5F,0xF5,0x8C,0xED,0x94,0xF3,0xCD,0xCE,0x73};

uint32_t ServiceState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_timeStamp = false;
  bool isset_address = false;
  bool isset_workers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->status = (ServiceStatus::type)ecast9;
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeStamp);
          isset_timeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->workers.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              PodID _key15;
              xfer += iprot->readI32(_key15);
              WorkerState& _val16 = this->workers[_key15];
              xfer += _val16.read(iprot);
            }
            iprot->readMapEnd();
          }
          isset_workers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_workers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServiceState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceState");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->timeStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("workers", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->workers.size()));
    std::map<PodID, WorkerState> ::const_iterator _iter17;
    for (_iter17 = this->workers.begin(); _iter17 != this->workers.end(); ++_iter17)
    {
      xfer += oprot->writeI32(_iter17->first);
      xfer += _iter17->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceState &a, ServiceState &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.timeStamp, b.timeStamp);
  swap(a.address, b.address);
  swap(a.workers, b.workers);
}

const char* HiveState::ascii_fingerprint = "EB7D21473380080E55471C125F7E739C";
const uint8_t HiveState::binary_fingerprint[16] = {0xEB,0x7D,0x21,0x47,0x33,0x80,0x08,0x0E,0x55,0x47,0x1C,0x12,0x5F,0x7E,0x73,0x9C};

uint32_t HiveState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topologyID = false;
  bool isset_services = false;
  bool isset_reportingHostID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->topologyID);
          isset_topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->services.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              HostID _key23;
              xfer += iprot->readI32(_key23);
              ServiceState& _val24 = this->services[_key23];
              xfer += _val24.read(iprot);
            }
            iprot->readMapEnd();
          }
          isset_services = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->reportingHostID);
          isset_reportingHostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topologyID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_services)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reportingHostID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HiveState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HiveState");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("services", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->services.size()));
    std::map<HostID, ServiceState> ::const_iterator _iter25;
    for (_iter25 = this->services.begin(); _iter25 != this->services.end(); ++_iter25)
    {
      xfer += oprot->writeI32(_iter25->first);
      xfer += _iter25->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportingHostID", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->reportingHostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveState &a, HiveState &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.services, b.services);
  swap(a.reportingHostID, b.reportingHostID);
}

const char* Topology::ascii_fingerprint = "8FFF1DF7A12AE69FE78268BC347A1EAE";
const uint8_t Topology::binary_fingerprint[16] = {0x8F,0xFF,0x1D,0xF7,0xA1,0x2A,0xE6,0x9F,0xE7,0x82,0x68,0xBC,0x34,0x7A,0x1E,0xAE};

uint32_t Topology::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topologyID = false;
  bool isset_hosts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->topologyID);
          isset_topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hosts.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              HostID _key31;
              xfer += iprot->readI32(_key31);
              Pods& _val32 = this->hosts[_key31];
              {
                _val32.clear();
                uint32_t _size33;
                ::apache::thrift::protocol::TType _ktype34;
                ::apache::thrift::protocol::TType _vtype35;
                iprot->readMapBegin(_ktype34, _vtype35, _size33);
                uint32_t _i37;
                for (_i37 = 0; _i37 < _size33; ++_i37)
                {
                  PodID _key38;
                  xfer += iprot->readI32(_key38);
                  ColumnIDs& _val39 = _val32[_key38];
                  {
                    _val39.clear();
                    uint32_t _size40;
                    ::apache::thrift::protocol::TType _etype43;
                    iprot->readListBegin(_etype43, _size40);
                    _val39.resize(_size40);
                    uint32_t _i44;
                    for (_i44 = 0; _i44 < _size40; ++_i44)
                    {
                      xfer += iprot->readI32(_val39[_i44]);
                    }
                    iprot->readListEnd();
                  }
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          isset_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topologyID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hosts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Topology::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Topology");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->hosts.size()));
    std::map<HostID, Pods> ::const_iterator _iter45;
    for (_iter45 = this->hosts.begin(); _iter45 != this->hosts.end(); ++_iter45)
    {
      xfer += oprot->writeI32(_iter45->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter45->second.size()));
        std::map<PodID, ColumnIDs> ::const_iterator _iter46;
        for (_iter46 = _iter45->second.begin(); _iter46 != _iter45->second.end(); ++_iter46)
        {
          xfer += oprot->writeI32(_iter46->first);
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter46->second.size()));
            std::vector<ColumnID> ::const_iterator _iter47;
            for (_iter47 = _iter46->second.begin(); _iter47 != _iter46->second.end(); ++_iter47)
            {
              xfer += oprot->writeI32((*_iter47));
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Topology &a, Topology &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.hosts, b.hosts);
}

const char* LockExpired::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t LockExpired::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t LockExpired::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockID);
          this->__isset.lockID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockExpired::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockExpired");

  xfer += oprot->writeFieldBegin("lockID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockExpired &a, LockExpired &b) {
  using ::std::swap;
  swap(a.lockID, b.lockID);
  swap(a.__isset, b.__isset);
}

const char* LockTimedOut::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t LockTimedOut::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t LockTimedOut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockTimedOut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockTimedOut");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockTimedOut &a, LockTimedOut &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* AlreadyJoined::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t AlreadyJoined::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t AlreadyJoined::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hostID);
          this->__isset.hostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyJoined::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AlreadyJoined");

  xfer += oprot->writeFieldBegin("hostID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->hostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyJoined &a, AlreadyJoined &b) {
  using ::std::swap;
  swap(a.hostID, b.hostID);
  swap(a.__isset, b.__isset);
}

const char* NotJoined::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t NotJoined::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t NotJoined::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotJoined::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotJoined");

  xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->potentialWorkers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotJoined &a, NotJoined &b) {
  using ::std::swap;
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* TransactionID::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TransactionID::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TransactionID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_revision = false;
  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          isset_revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_revision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TransactionID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TransactionID");

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionID &a, TransactionID &b) {
  using ::std::swap;
  swap(a.revision, b.revision);
  swap(a.key, b.key);
}

const char* Include::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t Include::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t Include::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_rowID = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          isset_rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_rowID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Include::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Include");

  xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->rowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Include &a, Include &b) {
  using ::std::swap;
  swap(a.rowID, b.rowID);
  swap(a.value, b.value);
}

const char* Exclude::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t Exclude::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t Exclude::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_rowID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          isset_rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_rowID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Exclude::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Exclude");

  xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->rowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exclude &a, Exclude &b) {
  using ::std::swap;
  swap(a.rowID, b.rowID);
}

const char* ColumnWrites::ascii_fingerprint = "7B474451502DF848AF475006A25AB746";
const uint8_t ColumnWrites::binary_fingerprint[16] = {0x7B,0x47,0x44,0x51,0x50,0x2D,0xF8,0x48,0xAF,0x47,0x50,0x06,0xA2,0x5A,0xB7,0x46};

uint32_t ColumnWrites::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->includes.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            iprot->readListBegin(_etype51, _size48);
            this->includes.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->includes[_i52].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->excludes.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            iprot->readListBegin(_etype56, _size53);
            this->excludes.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += this->excludes[_i57].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.excludes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnWrites::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnWrites");

  if (this->__isset.includes) {
    xfer += oprot->writeFieldBegin("includes", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->includes.size()));
      std::vector<Include> ::const_iterator _iter58;
      for (_iter58 = this->includes.begin(); _iter58 != this->includes.end(); ++_iter58)
      {
        xfer += (*_iter58).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excludes) {
    xfer += oprot->writeFieldBegin("excludes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->excludes.size()));
      std::vector<Exclude> ::const_iterator _iter59;
      for (_iter59 = this->excludes.begin(); _iter59 != this->excludes.end(); ++_iter59)
      {
        xfer += (*_iter59).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnWrites &a, ColumnWrites &b) {
  using ::std::swap;
  swap(a.includes, b.includes);
  swap(a.excludes, b.excludes);
  swap(a.__isset, b.__isset);
}

const char* Statistic::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t Statistic::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t Statistic::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_total = false;
  bool isset_unique = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total);
          isset_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unique);
          isset_unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_total)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unique)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Statistic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Statistic");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->unique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Statistic &a, Statistic &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.unique, b.unique);
}

const char* RangeBound::ascii_fingerprint = "7D61C9AA00102AB4D8F72A1DA58297DC";
const uint8_t RangeBound::binary_fingerprint[16] = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

uint32_t RangeBound::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_inclusive = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inclusive);
          isset_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inclusive)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeBound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeBound");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inclusive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->inclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeBound &a, RangeBound &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.inclusive, b.inclusive);
}

const char* RangeRequest::ascii_fingerprint = "4C1A8C7B2474BEEF3B5899689B4AC289";
const uint8_t RangeRequest::binary_fingerprint[16] = {0x4C,0x1A,0x8C,0x7B,0x24,0x74,0xBE,0xEF,0x3B,0x58,0x99,0x68,0x9B,0x4A,0xC2,0x89};

uint32_t RangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ascending = false;
  bool isset_limit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          isset_ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->first.read(iprot);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->last.read(iprot);
          this->__isset.last = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          this->__isset.rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ascending)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeRequest");

  xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->ascending);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->limit);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.first) {
    xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->first.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last) {
    xfer += oprot->writeFieldBegin("last", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->last.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rowID) {
    xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->rowID);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeRequest &a, RangeRequest &b) {
  using ::std::swap;
  swap(a.ascending, b.ascending);
  swap(a.limit, b.limit);
  swap(a.first, b.first);
  swap(a.last, b.last);
  swap(a.rowID, b.rowID);
  swap(a.__isset, b.__isset);
}

const char* ValueRows::ascii_fingerprint = "25702B8D5E28AA39160F267DABBC8446";
const uint8_t ValueRows::binary_fingerprint[16] = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

uint32_t ValueRows::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_rowIDs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDs.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            iprot->readListBegin(_etype63, _size60);
            this->rowIDs.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += iprot->readBinary(this->rowIDs[_i64]);
            }
            iprot->readListEnd();
          }
          isset_rowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rowIDs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ValueRows::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ValueRows");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rowIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDs.size()));
    std::vector<std::string> ::const_iterator _iter65;
    for (_iter65 = this->rowIDs.begin(); _iter65 != this->rowIDs.end(); ++_iter65)
    {
      xfer += oprot->writeBinary((*_iter65));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ValueRows &a, ValueRows &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.rowIDs, b.rowIDs);
}

const char* RangeResult::ascii_fingerprint = "A6BFD4A548133149EF24E6ED4F1025B8";
const uint8_t RangeResult::binary_fingerprint[16] = {0xA6,0xBF,0xD4,0xA5,0x48,0x13,0x31,0x49,0xEF,0x24,0xE6,0xED,0x4F,0x10,0x25,0xB8};

uint32_t RangeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_valueRowsList = false;
  bool isset_endOfRange = false;
  bool isset_beginOfRange = false;
  bool isset_limited = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueRowsList.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            iprot->readListBegin(_etype69, _size66);
            this->valueRowsList.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->valueRowsList[_i70].read(iprot);
            }
            iprot->readListEnd();
          }
          isset_valueRowsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->endOfRange);
          isset_endOfRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->beginOfRange);
          isset_beginOfRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->limited);
          isset_limited = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_valueRowsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endOfRange)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_beginOfRange)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limited)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeResult");

  xfer += oprot->writeFieldBegin("valueRowsList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->valueRowsList.size()));
    std::vector<ValueRows> ::const_iterator _iter71;
    for (_iter71 = this->valueRowsList.begin(); _iter71 != this->valueRowsList.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endOfRange", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->endOfRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("beginOfRange", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->beginOfRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limited", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->limited);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeResult &a, RangeResult &b) {
  using ::std::swap;
  swap(a.valueRowsList, b.valueRowsList);
  swap(a.endOfRange, b.endOfRange);
  swap(a.beginOfRange, b.beginOfRange);
  swap(a.limited, b.limited);
}

const char* Query::ascii_fingerprint = "C06DB9A662129FF3CAE53510F3482EB5";
const uint8_t Query::binary_fingerprint[16] = {0xC0,0x6D,0xB9,0xA6,0x62,0x12,0x9F,0xF3,0xCA,0xE5,0x35,0x10,0xF3,0x48,0x2E,0xB5};

uint32_t Query::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDs.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            iprot->readListBegin(_etype75, _size72);
            this->rowIDs.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += iprot->readBinary(this->rowIDs[_i76]);
            }
            iprot->readListEnd();
          }
          this->__isset.rowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            iprot->readListBegin(_etype80, _size77);
            this->ranges.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->ranges[_i81].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Query::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Query");

  if (this->__isset.rowIDs) {
    xfer += oprot->writeFieldBegin("rowIDs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDs.size()));
      std::vector<std::string> ::const_iterator _iter82;
      for (_iter82 = this->rowIDs.begin(); _iter82 != this->rowIDs.end(); ++_iter82)
      {
        xfer += oprot->writeBinary((*_iter82));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ranges) {
    xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
      std::vector<RangeRequest> ::const_iterator _iter83;
      for (_iter83 = this->ranges.begin(); _iter83 != this->ranges.end(); ++_iter83)
      {
        xfer += (*_iter83).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Query &a, Query &b) {
  using ::std::swap;
  swap(a.rowIDs, b.rowIDs);
  swap(a.ranges, b.ranges);
  swap(a.__isset, b.__isset);
}

const char* Answer::ascii_fingerprint = "2AE4F329512B9BFF283AD9D6279E124D";
const uint8_t Answer::binary_fingerprint[16] = {0x2A,0xE4,0xF3,0x29,0x51,0x2B,0x9B,0xFF,0x28,0x3A,0xD9,0xD6,0x27,0x9E,0x12,0x4D};

uint32_t Answer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDValues.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            iprot->readListBegin(_etype87, _size84);
            this->rowIDValues.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += iprot->readBinary(this->rowIDValues[_i88]);
            }
            iprot->readListEnd();
          }
          this->__isset.rowIDValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rangeValues.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            iprot->readListBegin(_etype92, _size89);
            this->rangeValues.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += this->rangeValues[_i93].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.rangeValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Answer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Answer");

  if (this->__isset.rowIDValues) {
    xfer += oprot->writeFieldBegin("rowIDValues", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDValues.size()));
      std::vector<std::string> ::const_iterator _iter94;
      for (_iter94 = this->rowIDValues.begin(); _iter94 != this->rowIDValues.end(); ++_iter94)
      {
        xfer += oprot->writeBinary((*_iter94));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rangeValues) {
    xfer += oprot->writeFieldBegin("rangeValues", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rangeValues.size()));
      std::vector<RangeResult> ::const_iterator _iter95;
      for (_iter95 = this->rangeValues.begin(); _iter95 != this->rangeValues.end(); ++_iter95)
      {
        xfer += (*_iter95).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Answer &a, Answer &b) {
  using ::std::swap;
  swap(a.rowIDValues, b.rowIDValues);
  swap(a.rangeValues, b.rangeValues);
  swap(a.__isset, b.__isset);
}

const char* ReadResult::ascii_fingerprint = "747FE1FFF63CCB61ABEB89C586E23870";
const uint8_t ReadResult::binary_fingerprint[16] = {0x74,0x7F,0xE1,0xFF,0xF6,0x3C,0xCB,0x61,0xAB,0xEB,0x89,0xC5,0x86,0xE2,0x38,0x70};

uint32_t ReadResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_answer = false;
  bool isset_revision = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->answer.read(iprot);
          isset_answer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          isset_revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_answer)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_revision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReadResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReadResult");

  xfer += oprot->writeFieldBegin("answer", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->answer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadResult &a, ReadResult &b) {
  using ::std::swap;
  swap(a.answer, b.answer);
  swap(a.revision, b.revision);
}

const char* NotLatest::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t NotLatest::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t NotLatest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latest);
          this->__isset.latest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotLatest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotLatest");

  xfer += oprot->writeFieldBegin("latest", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->latest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotLatest &a, NotLatest &b) {
  using ::std::swap;
  swap(a.latest, b.latest);
  swap(a.__isset, b.__isset);
}

const char* AlreadyPending::ascii_fingerprint = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
const uint8_t AlreadyPending::binary_fingerprint[16] = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

uint32_t AlreadyPending::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pendingTransactionID.read(iprot);
          this->__isset.pendingTransactionID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyPending::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AlreadyPending");

  xfer += oprot->writeFieldBegin("pendingTransactionID", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pendingTransactionID.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyPending &a, AlreadyPending &b) {
  using ::std::swap;
  swap(a.pendingTransactionID, b.pendingTransactionID);
  swap(a.__isset, b.__isset);
}

const char* Conflict::ascii_fingerprint = "920F6571EE6C0CF61556A788D6042213";
const uint8_t Conflict::binary_fingerprint[16] = {0x92,0x0F,0x65,0x71,0xEE,0x6C,0x0C,0xF6,0x15,0x56,0xA7,0x88,0xD6,0x04,0x22,0x13};

uint32_t Conflict::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->details);
          this->__isset.details = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnIDs.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            iprot->readListBegin(_etype99, _size96);
            this->columnIDs.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readI32(this->columnIDs[_i100]);
            }
            iprot->readListEnd();
          }
          this->__isset.columnIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Conflict::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Conflict");

  xfer += oprot->writeFieldBegin("details", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->details);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->columnIDs.size()));
    std::vector<ColumnID> ::const_iterator _iter101;
    for (_iter101 = this->columnIDs.begin(); _iter101 != this->columnIDs.end(); ++_iter101)
    {
      xfer += oprot->writeI32((*_iter101));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Conflict &a, Conflict &b) {
  using ::std::swap;
  swap(a.details, b.details);
  swap(a.columnIDs, b.columnIDs);
  swap(a.__isset, b.__isset);
}

const char* BeyondHistory::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t BeyondHistory::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t BeyondHistory::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minHistory);
          this->__isset.minHistory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BeyondHistory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BeyondHistory");

  xfer += oprot->writeFieldBegin("minHistory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minHistory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BeyondHistory &a, BeyondHistory &b) {
  using ::std::swap;
  swap(a.minHistory, b.minHistory);
  swap(a.__isset, b.__isset);
}

}} // namespace
