/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Comm_types.h"

#include <algorithm>

namespace fastore { namespace communication {

int _kRepositoryStatusValues[] = {
  RepositoryStatus::Loading,
  RepositoryStatus::Unloading,
  RepositoryStatus::Online,
  RepositoryStatus::Checkpointing,
  RepositoryStatus::Offline
};
const char* _kRepositoryStatusNames[] = {
  "Loading",
  "Unloading",
  "Online",
  "Checkpointing",
  "Offline"
};
const std::map<int, const char*> _RepositoryStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kRepositoryStatusValues, _kRepositoryStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kServiceStatusValues[] = {
  ServiceStatus::Unknown,
  ServiceStatus::Offline,
  ServiceStatus::Online,
  ServiceStatus::Unreachable
};
const char* _kServiceStatusNames[] = {
  "Unknown",
  "Offline",
  "Online",
  "Unreachable"
};
const std::map<int, const char*> _ServiceStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kServiceStatusValues, _kServiceStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLockModeValues[] = {
  LockMode::Read,
  LockMode::Write
};
const char* _kLockModeNames[] = {
  "Read",
  "Write"
};
const std::map<int, const char*> _LockMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLockModeValues, _kLockModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* NetworkAddress::ascii_fingerprint = "E17E126D15049701494262EE3246F603";
const uint8_t NetworkAddress::binary_fingerprint[16] = {0xE1,0x7E,0x12,0x6D,0x15,0x04,0x97,0x01,0x49,0x42,0x62,0xEE,0x32,0x46,0xF6,0x03};

uint32_t NetworkAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NetworkAddress");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->port);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkAddress &a, NetworkAddress &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

const char* WorkerState::ascii_fingerprint = "671173BA4A0889C63295D13F187AC67E";
const uint8_t WorkerState::binary_fingerprint[16] = {0x67,0x11,0x73,0xBA,0x4A,0x08,0x89,0xC6,0x32,0x95,0xD1,0x3F,0x18,0x7A,0xC6,0x7E};

uint32_t WorkerState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_podID = false;
  bool isset_repositoryStatus = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->podID);
          isset_podID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->repositoryStatus.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              ColumnID _key5;
              xfer += iprot->readI64(_key5);
              RepositoryStatus::type& _val6 = this->repositoryStatus[_key5];
              int32_t ecast7;
              xfer += iprot->readI32(ecast7);
              _val6 = (RepositoryStatus::type)ecast7;
            }
            xfer += iprot->readMapEnd();
          }
          isset_repositoryStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_podID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_repositoryStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkerState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("WorkerState");

  xfer += oprot->writeFieldBegin("podID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->podID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("repositoryStatus", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->repositoryStatus.size()));
    std::map<ColumnID, RepositoryStatus::type> ::const_iterator _iter8;
    for (_iter8 = this->repositoryStatus.begin(); _iter8 != this->repositoryStatus.end(); ++_iter8)
    {
      xfer += oprot->writeI64(_iter8->first);
      xfer += oprot->writeI32((int32_t)_iter8->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkerState &a, WorkerState &b) {
  using ::std::swap;
  swap(a.podID, b.podID);
  swap(a.repositoryStatus, b.repositoryStatus);
  swap(a.port, b.port);
}

const char* ServiceState::ascii_fingerprint = "A1199E740B9B4CA22D6FBE74944130AF";
const uint8_t ServiceState::binary_fingerprint[16] = {0xA1,0x19,0x9E,0x74,0x0B,0x9B,0x4C,0xA2,0x2D,0x6F,0xBE,0x74,0x94,0x41,0x30,0xAF};

uint32_t ServiceState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_timeStamp = false;
  bool isset_address = false;
  bool isset_workers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->status = (ServiceStatus::type)ecast9;
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeStamp);
          isset_timeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          isset_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->workers.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->workers.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->workers[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_workers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_address)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_workers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServiceState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceState");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->timeStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("workers", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->workers.size()));
    std::vector<WorkerState> ::const_iterator _iter15;
    for (_iter15 = this->workers.begin(); _iter15 != this->workers.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceState &a, ServiceState &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.timeStamp, b.timeStamp);
  swap(a.address, b.address);
  swap(a.workers, b.workers);
}

const char* HiveState::ascii_fingerprint = "A1CC6D56385C7C1FE3F049C8D742F1FF";
const uint8_t HiveState::binary_fingerprint[16] = {0xA1,0xCC,0x6D,0x56,0x38,0x5C,0x7C,0x1F,0xE3,0xF0,0x49,0xC8,0xD7,0x42,0xF1,0xFF};

uint32_t HiveState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topologyID = false;
  bool isset_services = false;
  bool isset_reportingHostID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topologyID);
          isset_topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->services.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              HostID _key21;
              xfer += iprot->readI64(_key21);
              ServiceState& _val22 = this->services[_key21];
              xfer += _val22.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_services = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reportingHostID);
          isset_reportingHostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topologyID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_services)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reportingHostID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HiveState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HiveState");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("services", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->services.size()));
    std::map<HostID, ServiceState> ::const_iterator _iter23;
    for (_iter23 = this->services.begin(); _iter23 != this->services.end(); ++_iter23)
    {
      xfer += oprot->writeI64(_iter23->first);
      xfer += _iter23->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reportingHostID", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->reportingHostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveState &a, HiveState &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.services, b.services);
  swap(a.reportingHostID, b.reportingHostID);
}

const char* Topology::ascii_fingerprint = "D99C034A9599DE1ADFF4DC218564E7B5";
const uint8_t Topology::binary_fingerprint[16] = {0xD9,0x9C,0x03,0x4A,0x95,0x99,0xDE,0x1A,0xDF,0xF4,0xDC,0x21,0x85,0x64,0xE7,0xB5};

uint32_t Topology::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topologyID = false;
  bool isset_hosts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topologyID);
          isset_topologyID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hosts.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              HostID _key29;
              xfer += iprot->readI64(_key29);
              Pods& _val30 = this->hosts[_key29];
              {
                _val30.clear();
                uint32_t _size31;
                ::apache::thrift::protocol::TType _ktype32;
                ::apache::thrift::protocol::TType _vtype33;
                xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
                uint32_t _i35;
                for (_i35 = 0; _i35 < _size31; ++_i35)
                {
                  PodID _key36;
                  xfer += iprot->readI64(_key36);
                  ColumnIDs& _val37 = _val30[_key36];
                  {
                    _val37.clear();
                    uint32_t _size38;
                    ::apache::thrift::protocol::TType _etype41;
                    xfer += iprot->readListBegin(_etype41, _size38);
                    _val37.resize(_size38);
                    uint32_t _i42;
                    for (_i42 = 0; _i42 < _size38; ++_i42)
                    {
                      xfer += iprot->readI64(_val37[_i42]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topologyID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hosts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Topology::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Topology");

  xfer += oprot->writeFieldBegin("topologyID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->topologyID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hosts", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->hosts.size()));
    std::map<HostID, Pods> ::const_iterator _iter43;
    for (_iter43 = this->hosts.begin(); _iter43 != this->hosts.end(); ++_iter43)
    {
      xfer += oprot->writeI64(_iter43->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter43->second.size()));
        std::map<PodID, ColumnIDs> ::const_iterator _iter44;
        for (_iter44 = _iter43->second.begin(); _iter44 != _iter43->second.end(); ++_iter44)
        {
          xfer += oprot->writeI64(_iter44->first);
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter44->second.size()));
            std::vector<ColumnID> ::const_iterator _iter45;
            for (_iter45 = _iter44->second.begin(); _iter45 != _iter44->second.end(); ++_iter45)
            {
              xfer += oprot->writeI64((*_iter45));
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Topology &a, Topology &b) {
  using ::std::swap;
  swap(a.topologyID, b.topologyID);
  swap(a.hosts, b.hosts);
}

const char* OptionalHiveState::ascii_fingerprint = "4D5C48147F5DC789C640DAB00E9C8BC3";
const uint8_t OptionalHiveState::binary_fingerprint[16] = {0x4D,0x5C,0x48,0x14,0x7F,0x5D,0xC7,0x89,0xC6,0x40,0xDA,0xB0,0x0E,0x9C,0x8B,0xC3};

uint32_t OptionalHiveState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hiveState.read(iprot);
          this->__isset.hiveState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalHiveState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OptionalHiveState");

  if (this->__isset.hiveState) {
    xfer += oprot->writeFieldBegin("hiveState", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->hiveState.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.potentialWorkers) {
    xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->potentialWorkers);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalHiveState &a, OptionalHiveState &b) {
  using ::std::swap;
  swap(a.hiveState, b.hiveState);
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* OptionalServiceState::ascii_fingerprint = "9207B221A88F594F4277871EFF583B03";
const uint8_t OptionalServiceState::binary_fingerprint[16] = {0x92,0x07,0xB2,0x21,0xA8,0x8F,0x59,0x4F,0x42,0x77,0x87,0x1E,0xFF,0x58,0x3B,0x03};

uint32_t OptionalServiceState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serviceState.read(iprot);
          this->__isset.serviceState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalServiceState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OptionalServiceState");

  if (this->__isset.serviceState) {
    xfer += oprot->writeFieldBegin("serviceState", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->serviceState.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.potentialWorkers) {
    xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->potentialWorkers);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalServiceState &a, OptionalServiceState &b) {
  using ::std::swap;
  swap(a.serviceState, b.serviceState);
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* LockExpired::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t LockExpired::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t LockExpired::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockID);
          this->__isset.lockID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockExpired::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockExpired");

  xfer += oprot->writeFieldBegin("lockID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockExpired &a, LockExpired &b) {
  using ::std::swap;
  swap(a.lockID, b.lockID);
  swap(a.__isset, b.__isset);
}

const char* LockTimedOut::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t LockTimedOut::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t LockTimedOut::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LockTimedOut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LockTimedOut");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockTimedOut &a, LockTimedOut &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* AlreadyJoined::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t AlreadyJoined::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t AlreadyJoined::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hostID);
          this->__isset.hostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyJoined::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AlreadyJoined");

  xfer += oprot->writeFieldBegin("hostID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->hostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyJoined &a, AlreadyJoined &b) {
  using ::std::swap;
  swap(a.hostID, b.hostID);
  swap(a.__isset, b.__isset);
}

const char* NotJoined::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t NotJoined::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t NotJoined::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->potentialWorkers);
          this->__isset.potentialWorkers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotJoined::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotJoined");

  xfer += oprot->writeFieldBegin("potentialWorkers", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->potentialWorkers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotJoined &a, NotJoined &b) {
  using ::std::swap;
  swap(a.potentialWorkers, b.potentialWorkers);
  swap(a.__isset, b.__isset);
}

const char* TransactionID::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TransactionID::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TransactionID::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_revision = false;
  bool isset_key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          isset_revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_revision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TransactionID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TransactionID");

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransactionID &a, TransactionID &b) {
  using ::std::swap;
  swap(a.revision, b.revision);
  swap(a.key, b.key);
}

const char* Include::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t Include::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t Include::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_rowID = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          isset_rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_rowID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Include::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Include");

  xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->rowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Include &a, Include &b) {
  using ::std::swap;
  swap(a.rowID, b.rowID);
  swap(a.value, b.value);
}

const char* Exclude::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t Exclude::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t Exclude::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_rowID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          isset_rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_rowID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Exclude::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Exclude");

  xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->rowID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exclude &a, Exclude &b) {
  using ::std::swap;
  swap(a.rowID, b.rowID);
}

const char* ColumnWrites::ascii_fingerprint = "7B474451502DF848AF475006A25AB746";
const uint8_t ColumnWrites::binary_fingerprint[16] = {0x7B,0x47,0x44,0x51,0x50,0x2D,0xF8,0x48,0xAF,0x47,0x50,0x06,0xA2,0x5A,0xB7,0x46};

uint32_t ColumnWrites::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->includes.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->includes.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->includes[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->excludes.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->excludes.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += this->excludes[_i55].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.excludes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnWrites::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnWrites");

  if (this->__isset.includes) {
    xfer += oprot->writeFieldBegin("includes", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->includes.size()));
      std::vector<Include> ::const_iterator _iter56;
      for (_iter56 = this->includes.begin(); _iter56 != this->includes.end(); ++_iter56)
      {
        xfer += (*_iter56).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excludes) {
    xfer += oprot->writeFieldBegin("excludes", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->excludes.size()));
      std::vector<Exclude> ::const_iterator _iter57;
      for (_iter57 = this->excludes.begin(); _iter57 != this->excludes.end(); ++_iter57)
      {
        xfer += (*_iter57).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnWrites &a, ColumnWrites &b) {
  using ::std::swap;
  swap(a.includes, b.includes);
  swap(a.excludes, b.excludes);
  swap(a.__isset, b.__isset);
}

const char* Statistic::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t Statistic::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t Statistic::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_total = false;
  bool isset_unique = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total);
          isset_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->unique);
          isset_unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_total)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unique)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Statistic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Statistic");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->unique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Statistic &a, Statistic &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.unique, b.unique);
}

const char* RangeBound::ascii_fingerprint = "7D61C9AA00102AB4D8F72A1DA58297DC";
const uint8_t RangeBound::binary_fingerprint[16] = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

uint32_t RangeBound::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_inclusive = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inclusive);
          isset_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inclusive)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeBound::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeBound");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inclusive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->inclusive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeBound &a, RangeBound &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.inclusive, b.inclusive);
}

const char* RangeRequest::ascii_fingerprint = "4C1A8C7B2474BEEF3B5899689B4AC289";
const uint8_t RangeRequest::binary_fingerprint[16] = {0x4C,0x1A,0x8C,0x7B,0x24,0x74,0xBE,0xEF,0x3B,0x58,0x99,0x68,0x9B,0x4A,0xC2,0x89};

uint32_t RangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ascending = false;
  bool isset_limit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          isset_ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->first.read(iprot);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->last.read(iprot);
          this->__isset.last = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rowID);
          this->__isset.rowID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ascending)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeRequest");

  xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->ascending);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->limit);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.first) {
    xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->first.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last) {
    xfer += oprot->writeFieldBegin("last", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->last.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rowID) {
    xfer += oprot->writeFieldBegin("rowID", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->rowID);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeRequest &a, RangeRequest &b) {
  using ::std::swap;
  swap(a.ascending, b.ascending);
  swap(a.limit, b.limit);
  swap(a.first, b.first);
  swap(a.last, b.last);
  swap(a.rowID, b.rowID);
  swap(a.__isset, b.__isset);
}

const char* ValueRows::ascii_fingerprint = "25702B8D5E28AA39160F267DABBC8446";
const uint8_t ValueRows::binary_fingerprint[16] = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

uint32_t ValueRows::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_value = false;
  bool isset_rowIDs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDs.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->rowIDs.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readBinary(this->rowIDs[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          isset_rowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rowIDs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ValueRows::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ValueRows");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rowIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDs.size()));
    std::vector<std::string> ::const_iterator _iter63;
    for (_iter63 = this->rowIDs.begin(); _iter63 != this->rowIDs.end(); ++_iter63)
    {
      xfer += oprot->writeBinary((*_iter63));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ValueRows &a, ValueRows &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.rowIDs, b.rowIDs);
}

const char* RangeResult::ascii_fingerprint = "A6BFD4A548133149EF24E6ED4F1025B8";
const uint8_t RangeResult::binary_fingerprint[16] = {0xA6,0xBF,0xD4,0xA5,0x48,0x13,0x31,0x49,0xEF,0x24,0xE6,0xED,0x4F,0x10,0x25,0xB8};

uint32_t RangeResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_valueRowsList = false;
  bool isset_eof = false;
  bool isset_bof = false;
  bool isset_limited = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueRowsList.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->valueRowsList.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->valueRowsList[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueRowsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->eof);
          isset_eof = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bof);
          isset_bof = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->limited);
          isset_limited = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_valueRowsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eof)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bof)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limited)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RangeResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RangeResult");

  xfer += oprot->writeFieldBegin("valueRowsList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->valueRowsList.size()));
    std::vector<ValueRows> ::const_iterator _iter69;
    for (_iter69 = this->valueRowsList.begin(); _iter69 != this->valueRowsList.end(); ++_iter69)
    {
      xfer += (*_iter69).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eof", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->eof);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bof", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bof);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limited", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->limited);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeResult &a, RangeResult &b) {
  using ::std::swap;
  swap(a.valueRowsList, b.valueRowsList);
  swap(a.eof, b.eof);
  swap(a.bof, b.bof);
  swap(a.limited, b.limited);
}

const char* Query::ascii_fingerprint = "C06DB9A662129FF3CAE53510F3482EB5";
const uint8_t Query::binary_fingerprint[16] = {0xC0,0x6D,0xB9,0xA6,0x62,0x12,0x9F,0xF3,0xCA,0xE5,0x35,0x10,0xF3,0x48,0x2E,0xB5};

uint32_t Query::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDs.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readListBegin(_etype73, _size70);
            this->rowIDs.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += iprot->readBinary(this->rowIDs[_i74]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rowIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->ranges.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->ranges[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Query::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Query");

  if (this->__isset.rowIDs) {
    xfer += oprot->writeFieldBegin("rowIDs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rowIDs.size()));
      std::vector<std::string> ::const_iterator _iter80;
      for (_iter80 = this->rowIDs.begin(); _iter80 != this->rowIDs.end(); ++_iter80)
      {
        xfer += oprot->writeBinary((*_iter80));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ranges) {
    xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ranges.size()));
      std::vector<RangeRequest> ::const_iterator _iter81;
      for (_iter81 = this->ranges.begin(); _iter81 != this->ranges.end(); ++_iter81)
      {
        xfer += (*_iter81).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Query &a, Query &b) {
  using ::std::swap;
  swap(a.rowIDs, b.rowIDs);
  swap(a.ranges, b.ranges);
  swap(a.__isset, b.__isset);
}

const char* OptionalValue::ascii_fingerprint = "66E694018C17E5B65A59AE8F55CCA3CD";
const uint8_t OptionalValue::binary_fingerprint[16] = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

uint32_t OptionalValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptionalValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OptionalValue");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptionalValue &a, OptionalValue &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Answer::ascii_fingerprint = "22FA14862D806BF9DFE908DF249FC6CF";
const uint8_t Answer::binary_fingerprint[16] = {0x22,0xFA,0x14,0x86,0x2D,0x80,0x6B,0xF9,0xDF,0xE9,0x08,0xDF,0x24,0x9F,0xC6,0xCF};

uint32_t Answer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rowIDValues.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->rowIDValues.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += this->rowIDValues[_i86].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rowIDValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rangeValues.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->rangeValues.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->rangeValues[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rangeValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Answer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Answer");

  if (this->__isset.rowIDValues) {
    xfer += oprot->writeFieldBegin("rowIDValues", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rowIDValues.size()));
      std::vector<OptionalValue> ::const_iterator _iter92;
      for (_iter92 = this->rowIDValues.begin(); _iter92 != this->rowIDValues.end(); ++_iter92)
      {
        xfer += (*_iter92).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rangeValues) {
    xfer += oprot->writeFieldBegin("rangeValues", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rangeValues.size()));
      std::vector<RangeResult> ::const_iterator _iter93;
      for (_iter93 = this->rangeValues.begin(); _iter93 != this->rangeValues.end(); ++_iter93)
      {
        xfer += (*_iter93).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Answer &a, Answer &b) {
  using ::std::swap;
  swap(a.rowIDValues, b.rowIDValues);
  swap(a.rangeValues, b.rangeValues);
  swap(a.__isset, b.__isset);
}

const char* ReadResult::ascii_fingerprint = "959469BBAB93041F240CB804FD38363D";
const uint8_t ReadResult::binary_fingerprint[16] = {0x95,0x94,0x69,0xBB,0xAB,0x93,0x04,0x1F,0x24,0x0C,0xB8,0x04,0xFD,0x38,0x36,0x3D};

uint32_t ReadResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_answer = false;
  bool isset_revision = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->answer.read(iprot);
          isset_answer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          isset_revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_answer)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_revision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReadResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReadResult");

  xfer += oprot->writeFieldBegin("answer", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->answer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->revision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadResult &a, ReadResult &b) {
  using ::std::swap;
  swap(a.answer, b.answer);
  swap(a.revision, b.revision);
}

const char* NotLatest::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t NotLatest::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t NotLatest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latest);
          this->__isset.latest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotLatest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotLatest");

  xfer += oprot->writeFieldBegin("latest", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->latest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotLatest &a, NotLatest &b) {
  using ::std::swap;
  swap(a.latest, b.latest);
  swap(a.__isset, b.__isset);
}

const char* AlreadyPending::ascii_fingerprint = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
const uint8_t AlreadyPending::binary_fingerprint[16] = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

uint32_t AlreadyPending::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pendingTransactionID.read(iprot);
          this->__isset.pendingTransactionID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyPending::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AlreadyPending");

  xfer += oprot->writeFieldBegin("pendingTransactionID", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pendingTransactionID.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyPending &a, AlreadyPending &b) {
  using ::std::swap;
  swap(a.pendingTransactionID, b.pendingTransactionID);
  swap(a.__isset, b.__isset);
}

const char* Conflict::ascii_fingerprint = "C1CFA7E6A57E07BC349AA430D41D6D57";
const uint8_t Conflict::binary_fingerprint[16] = {0xC1,0xCF,0xA7,0xE6,0xA5,0x7E,0x07,0xBC,0x34,0x9A,0xA4,0x30,0xD4,0x1D,0x6D,0x57};

uint32_t Conflict::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->details);
          this->__isset.details = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnIDs.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->columnIDs.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += iprot->readI64(this->columnIDs[_i98]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnIDs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Conflict::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Conflict");

  xfer += oprot->writeFieldBegin("details", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->details);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnIDs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->columnIDs.size()));
    std::vector<ColumnID> ::const_iterator _iter99;
    for (_iter99 = this->columnIDs.begin(); _iter99 != this->columnIDs.end(); ++_iter99)
    {
      xfer += oprot->writeI64((*_iter99));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Conflict &a, Conflict &b) {
  using ::std::swap;
  swap(a.details, b.details);
  swap(a.columnIDs, b.columnIDs);
  swap(a.__isset, b.__isset);
}

const char* BeyondHistory::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t BeyondHistory::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t BeyondHistory::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minHistory);
          this->__isset.minHistory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BeyondHistory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BeyondHistory");

  xfer += oprot->writeFieldBegin("minHistory", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minHistory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BeyondHistory &a, BeyondHistory &b) {
  using ::std::swap;
  swap(a.minHistory, b.minHistory);
  swap(a.__isset, b.__isset);
}

}} // namespace
