Index: trunk/lib/cpp/src/thrift/protocol/TBinaryProtocol.h
===================================================================
--- trunk/lib/cpp/src/thrift/protocol/TBinaryProtocol.h	(revision 1381333)
+++ trunk/lib/cpp/src/thrift/protocol/TBinaryProtocol.h	(working copy)
@@ -130,7 +130,8 @@
 
   inline uint32_t writeI32(const int32_t i32);
 
-  inline uint32_t writeI64(const int64_t i64);
+  inline uint32_t writeI64(const  int64_t i64);
+  inline uint32_t writeI64(const uint64_t i64);
 
   inline uint32_t writeDouble(const double dub);
 
Index: trunk/lib/cocoa/src/protocol/TBinaryProtocol.h
===================================================================
--- trunk/lib/cocoa/src/protocol/TBinaryProtocol.h	(revision 1381333)
+++ trunk/lib/cocoa/src/protocol/TBinaryProtocol.h	(working copy)
@@ -17,35 +17,267 @@
  * under the License.
  */
 
-#import "TProtocol.h"
-#import "TTransport.h"
-#import "TProtocolFactory.h"
+#ifndef _THRIFT_PROTOCOL_TBINARYPROTOCOL_H_
+#define _THRIFT_PROTOCOL_TBINARYPROTOCOL_H_ 1
 
+#include "TProtocol.h"
+#include "TVirtualProtocol.h"
 
-@interface TBinaryProtocol : NSObject <TProtocol> {
-  id <TTransport> mTransport;
-  BOOL mStrictRead;
-  BOOL mStrictWrite;
-  int32_t mMessageSizeLimit;
-}
+#include <boost/shared_ptr.hpp>
 
-- (id) initWithTransport: (id <TTransport>) transport;
+namespace apache { namespace thrift { namespace protocol {
 
-- (id) initWithTransport: (id <TTransport>) transport
-              strictRead: (BOOL) strictRead
-             strictWrite: (BOOL) strictWrite;
+/**
+ * The default binary protocol for thrift. Writes all data in a very basic
+ * binary format, essentially just spitting out the raw bytes.
+ *
+ */
+template <class Transport_>
+class TBinaryProtocolT
+  : public TVirtualProtocol< TBinaryProtocolT<Transport_> > {
+ protected:
+  static const int32_t VERSION_MASK = ((int32_t)0xffff0000);
+  static const int32_t VERSION_1 = ((int32_t)0x80010000);
+  // VERSION_2 (0x80020000)  is taken by TDenseProtocol.
 
-- (int32_t) messageSizeLimit;
-- (void) setMessageSizeLimit: (int32_t) sizeLimit;
+ public:
+  TBinaryProtocolT(boost::shared_ptr<Transport_> trans) :
+    TVirtualProtocol< TBinaryProtocolT<Transport_> >(trans),
+    trans_(trans.get()),
+    string_limit_(0),
+    container_limit_(0),
+    strict_read_(false),
+    strict_write_(true),
+    string_buf_(NULL),
+    string_buf_size_(0) {}
 
-@end;
+  TBinaryProtocolT(boost::shared_ptr<Transport_> trans,
+                   int32_t string_limit,
+                   int32_t container_limit,
+                   bool strict_read,
+                   bool strict_write) :
+    TVirtualProtocol< TBinaryProtocolT<Transport_> >(trans),
+    trans_(trans.get()),
+    string_limit_(string_limit),
+    container_limit_(container_limit),
+    strict_read_(strict_read),
+    strict_write_(strict_write),
+    string_buf_(NULL),
+    string_buf_size_(0) {}
 
+  ~TBinaryProtocolT() {
+    if (string_buf_ != NULL) {
+      std::free(string_buf_);
+      string_buf_size_ = 0;
+    }
+  }
 
-@interface TBinaryProtocolFactory : NSObject <TProtocolFactory> {
-}
+  void setStringSizeLimit(int32_t string_limit) {
+    string_limit_ = string_limit;
+  }
 
-+ (TBinaryProtocolFactory *) sharedFactory;
+  void setContainerSizeLimit(int32_t container_limit) {
+    container_limit_ = container_limit;
+  }
 
-- (TBinaryProtocol *) newProtocolOnTransport: (id <TTransport>) transport;
+  void setStrict(bool strict_read, bool strict_write) {
+    strict_read_ = strict_read;
+    strict_write_ = strict_write;
+  }
 
-@end
+  /**
+   * Writing functions.
+   */
+
+  /*ol*/ uint32_t writeMessageBegin(const std::string& name,
+                                    const TMessageType messageType,
+                                    const int32_t seqid);
+
+  /*ol*/ uint32_t writeMessageEnd();
+
+
+  inline uint32_t writeStructBegin(const char* name);
+
+  inline uint32_t writeStructEnd();
+
+  inline uint32_t writeFieldBegin(const char* name,
+                                  const TType fieldType,
+                                  const int16_t fieldId);
+
+  inline uint32_t writeFieldEnd();
+
+  inline uint32_t writeFieldStop();
+
+  inline uint32_t writeMapBegin(const TType keyType,
+                                const TType valType,
+                                const uint32_t size);
+
+  inline uint32_t writeMapEnd();
+
+  inline uint32_t writeListBegin(const TType elemType, const uint32_t size);
+
+  inline uint32_t writeListEnd();
+
+  inline uint32_t writeSetBegin(const TType elemType, const uint32_t size);
+
+  inline uint32_t writeSetEnd();
+
+  inline uint32_t writeBool(const bool value);
+
+  inline uint32_t writeByte(const int8_t byte);
+
+  inline uint32_t writeI16(const int16_t i16);
+
+  inline uint32_t writeI32(const int32_t i32);
+
+  inline uint32_t writeI64(const  int64_t i64);
+  inline uint32_t writeI64(const uint64_t i64);
+
+  inline uint32_t writeDouble(const double dub);
+
+  template <typename StrType>
+  inline uint32_t writeString(const StrType& str);
+
+  inline uint32_t writeBinary(const std::string& str);
+
+  /**
+   * Reading functions
+   */
+
+
+  /*ol*/ uint32_t readMessageBegin(std::string& name,
+                                   TMessageType& messageType,
+                                   int32_t& seqid);
+
+  /*ol*/ uint32_t readMessageEnd();
+
+  inline uint32_t readStructBegin(std::string& name);
+
+  inline uint32_t readStructEnd();
+
+  inline uint32_t readFieldBegin(std::string& name,
+                                 TType& fieldType,
+                                 int16_t& fieldId);
+
+  inline uint32_t readFieldEnd();
+
+  inline uint32_t readMapBegin(TType& keyType,
+                               TType& valType,
+                               uint32_t& size);
+
+  inline uint32_t readMapEnd();
+
+  inline uint32_t readListBegin(TType& elemType, uint32_t& size);
+
+  inline uint32_t readListEnd();
+
+  inline uint32_t readSetBegin(TType& elemType, uint32_t& size);
+
+  inline uint32_t readSetEnd();
+
+  inline uint32_t readBool(bool& value);
+  // Provide the default readBool() implementation for std::vector<bool>
+  using TVirtualProtocol< TBinaryProtocolT<Transport_> >::readBool;
+
+  inline uint32_t readByte(int8_t& byte);
+
+  inline uint32_t readI16(int16_t& i16);
+
+  inline uint32_t readI32(int32_t& i32);
+
+  inline uint32_t readI64(int64_t& i64);
+
+  inline uint32_t readDouble(double& dub);
+
+  template<typename StrType>
+  inline uint32_t readString(StrType& str);
+
+  inline uint32_t readBinary(std::string& str);
+
+ protected:
+  template<typename StrType>
+  uint32_t readStringBody(StrType& str, int32_t sz);
+
+  Transport_* trans_;
+
+  int32_t string_limit_;
+  int32_t container_limit_;
+
+  // Enforce presence of version identifier
+  bool strict_read_;
+  bool strict_write_;
+
+  // Buffer for reading strings, save for the lifetime of the protocol to
+  // avoid memory churn allocating memory on every string read
+  uint8_t* string_buf_;
+  int32_t string_buf_size_;
+
+};
+
+typedef TBinaryProtocolT<TTransport> TBinaryProtocol;
+
+/**
+ * Constructs binary protocol handlers
+ */
+template <class Transport_>
+class TBinaryProtocolFactoryT : public TProtocolFactory {
+ public:
+  TBinaryProtocolFactoryT() :
+    string_limit_(0),
+    container_limit_(0),
+    strict_read_(false),
+    strict_write_(true) {}
+
+  TBinaryProtocolFactoryT(int32_t string_limit, int32_t container_limit,
+                          bool strict_read, bool strict_write) :
+    string_limit_(string_limit),
+    container_limit_(container_limit),
+    strict_read_(strict_read),
+    strict_write_(strict_write) {}
+
+  virtual ~TBinaryProtocolFactoryT() {}
+
+  void setStringSizeLimit(int32_t string_limit) {
+    string_limit_ = string_limit;
+  }
+
+  void setContainerSizeLimit(int32_t container_limit) {
+    container_limit_ = container_limit;
+  }
+
+  void setStrict(bool strict_read, bool strict_write) {
+    strict_read_ = strict_read;
+    strict_write_ = strict_write;
+  }
+
+  boost::shared_ptr<TProtocol> getProtocol(boost::shared_ptr<TTransport> trans) {
+    boost::shared_ptr<Transport_> specific_trans =
+      boost::dynamic_pointer_cast<Transport_>(trans);
+    TProtocol* prot;
+    if (specific_trans) {
+      prot = new TBinaryProtocolT<Transport_>(specific_trans, string_limit_,
+                                              container_limit_, strict_read_,
+                                              strict_write_);
+    } else {
+      prot = new TBinaryProtocol(trans, string_limit_, container_limit_,
+                                 strict_read_, strict_write_);
+    }
+
+    return boost::shared_ptr<TProtocol>(prot);
+  }
+
+ private:
+  int32_t string_limit_;
+  int32_t container_limit_;
+  bool strict_read_;
+  bool strict_write_;
+
+};
+
+typedef TBinaryProtocolFactoryT<TTransport> TBinaryProtocolFactory;
+
+}}} // apache::thrift::protocol
+
+#include "TBinaryProtocol.tcc"
+
+#endif // #ifndef _THRIFT_PROTOCOL_TBINARYPROTOCOL_H_
